<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Linux Shell编程-基础教程</title>
    <url>/2020/03/22/Linux-Shell%E7%BC%96%E7%A8%8B-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="Linux-Shell-编程"><a href="#Linux-Shell-编程" class="headerlink" title="Linux Shell 编程"></a>Linux Shell 编程</h1><p>由于Linux不同于Windows，Linux是内核与界面分离的，它可以脱离图形界面而单独运行，同样也可以在内核的基础上运行图形化的桌面。</p>
<a id="more"></a>
<p>这样，在Linux系统中，就出现了两种shell表现形式，一种是在无图形界面下的终端运行环境下的shell，另一种是桌面上运行的类似Windows 的MS-DOS运行窗口，前者我们一般习惯性地简称为终端，后者一般直接称为shell<br><img src="/images/shell.png" alt="Shell图解"></p>
<h1 id="什么是Shell脚本？"><a href="#什么是Shell脚本？" class="headerlink" title="什么是Shell脚本？"></a>什么是Shell脚本？</h1><p>Shell脚本（英语：Shell script）是一种电脑程序与文本文件，内容由一连串的shell命令组成，经由Unix Shell直译其内容后运作。被当成是一种脚本语言来设计，其运作方式与直译语言相当，由Unix shell扮演命令行解释器的角色，在读取shell script之后，依序运行其中的shell命令，之后输出结果。利用Shell script可以进行系统管理，文件操作等。<br>在Unix及所有的类Unix系统中，如Linux、FreeBSD等操作系统，都存在Shell Script。依照Unix shell的各种不同类型，Shell script也有各种不同方言。在DOS、OS/2、Microsoft Windows中的批处理文件，跟shell script有类似的功能。<br>来看一个实例</p>
<pre><code>#!/bin/sh
cd ~
mkdir shell_tut
cd shell_tut
for ((i=0; i&lt;10; i++)); do
    touch test_$i.txt
done
实例解析：
第1行：指定脚本解释器，这里是用/bin/sh做解释器的
第2行：切换到当前用户的home目录
第3行：创建一个目录shell_tut
第4行：切换到shell_tut目录
第5行：循环条件，一共循环10次
第6行：创建一个test_1…10.txt文件
第7行：循环体结束</code></pre><p>cd, mkdir, touch都是系统自带的程序，一般在/bin或者/usr/bin目录下。for, do, done是sh脚本语言的关键字。</p>
<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>shell编程跟java、php编程一样，只要有一个能编写代码的文本编辑器和一个能解释执行的脚本解释器就可以了。<br>当前主流的操作系统都支持shell编程，本文档所述的shell编程是指Linux下的shell，讲的基本都是POSIX标准下的功能，所以，也适用于Unix及BSD（如Mac OS）。<br>Linux<br>Linux默认安装就带了shell解释器。<br>Mac OS<br>Mac OS不仅带了sh、bash这两个最基础的解释器，还内置了ksh、csh、zsh等不常用的解释器。<br>Windows上的模拟器<br>windows出厂时没有内置shell解释器，需要自行安装，为了同时能用grep, awk, curl等工具，最好装一个cygwin或者mingw来模拟linux环境。</p>
<h1 id="脚本解释器"><a href="#脚本解释器" class="headerlink" title="脚本解释器"></a>脚本解释器</h1><h1 id="sh"><a href="#sh" class="headerlink" title="sh"></a>sh</h1><p>即Bourne shell，POSIX（Portable Operating System Interface）标准的shell解释器，它的二进制文件路径通常是/bin/sh，由Bell Labs开发。</p>
<h1 id="bash"><a href="#bash" class="headerlink" title="bash"></a>bash</h1><p>Bash是Bourne shell的替代品，属GNU Project，二进制文件路径通常是/bin/bash。业界通常混用bash、sh、和shell，比如你会经常在招聘运维工程师的文案中见到：熟悉Linux Bash编程，精通Shell编程。<br>在CentOS里，/bin/sh是一个指向/bin/bash的符号链接:</p>
<pre><code>[root@centosraw ~]# ls -l /bin/*sh
-rwxr-xr-x. 1 root root 903272 Feb 22 05:09 /bin/bash
-rwxr-xr-x. 1 root root 106216 Oct 17  2012 /bin/dash
lrwxrwxrwx. 1 root root      4 Mar 22 10:22 /bin/sh -&gt; bash
但在Mac OS上不是，/bin/sh和/bin/bash是两个不同的文件，尽管它们的大小只相差100字节左右:

iMac:~ wuxiao$ ls -l /bin/*sh
-r-xr-xr-x  1 root  wheel  1371648  6 Nov 16:52 /bin/bash
-rwxr-xr-x  2 root  wheel   772992  6 Nov 16:52 /bin/csh
-r-xr-xr-x  1 root  wheel  2180736  6 Nov 16:52 /bin/ksh
-r-xr-xr-x  1 root  wheel  1371712  6 Nov 16:52 /bin/sh
-rwxr-xr-x  2 root  wheel   772992  6 Nov 16:52 /bin/tcsh
-rwxr-xr-x  1 root  wheel  1103984  6 Nov 16:52 /bin/zsh</code></pre><h1 id="高级编程语言"><a href="#高级编程语言" class="headerlink" title="高级编程语言"></a>高级编程语言</h1><p>理论上讲，只要一门语言提供了解释器（而不仅是编译器），这门语言就可以胜任脚本编程，常见的解释型语言都是可以用作脚本编程的，如：Perl、Tcl、Python、PHP、Ruby。Perl是最老牌的脚本编程语言了，Python这些年也成了一些linux发行版的预置解释器。</p>
<p>编译型语言，只要有解释器，也可以用作脚本编程，如C shell是内置的（/bin/csh），Java有第三方解释器Jshell，Ada有收费的解释器AdaScript。</p>
<p>如下是一个PHP Shell Script示例（假设文件名叫test.php）：</p>
<pre><code>#!/usr/bin/php
&lt;?php
for ($i=0; $i &lt; 10; $i++) {
    echo $i . &quot;\n&quot;;
}</code></pre><p>执行：</p>
<pre><code>/usr/bin/php test.php</code></pre><p>或者：</p>
<pre><code>chmod +x test.php
./test.php</code></pre><h1 id="如何选择shell编程语言"><a href="#如何选择shell编程语言" class="headerlink" title="如何选择shell编程语言"></a>如何选择shell编程语言</h1><h1 id="熟悉-vs-陌生"><a href="#熟悉-vs-陌生" class="headerlink" title="熟悉 vs 陌生"></a>熟悉 vs 陌生</h1><p>如果你已经掌握了一门编程语言（如PHP、Python、Java、JavaScript），建议你就直接使用这门语言编写脚本程序，虽然某些地方会有点啰嗦，但你能利用在这门语言领域里的经验（单元测试、单步调试、IDE、第三方类库）。</p>
<p>新增的学习成本很小，只要学会怎么使用shell解释器（Jshell、AdaScript）就可以了。</p>
<h1 id="简单-vs-高级"><a href="#简单-vs-高级" class="headerlink" title="简单 vs 高级"></a>简单 vs 高级</h1><p>如果你觉得自己熟悉的语言（如Java、C）写shell脚本实在太啰嗦，你只是想做一些备份文件、安装软件、下载数据之类的事情，学着使用sh，bash会是一个好主意。</p>
<p>shell只定义了一个非常简单的编程语言，所以，如果你的脚本程序复杂度较高，或者要操作的数据结构比较复杂，那么还是应该使用Python、Perl这样的脚本语言，或者是你本来就已经很擅长的高级语言。因为sh和bash在这方面很弱，比如说：</p>
<p>它的函数只能返回字串，无法返回数组<br>它不支持面向对象，你无法实现一些优雅的设计模式<br>它是解释型的，一边解释一边执行，连PHP那种预编译都不是，如果你的脚本包含错误(例如调用了不存在的函数)，只要没执行到这一行，就不会报错</p>
<h1 id="环境兼容性"><a href="#环境兼容性" class="headerlink" title="环境兼容性"></a>环境兼容性</h1><p>如果你的脚本是提供给别的用户使用，使用sh或者bash，你的脚本将具有最好的环境兼容性，perl很早就是linux标配了，python这些年也成了一些linux发行版的标配，至于mac os，它默认安装了perl、python、ruby、php、java等主流编程语言。</p>
<h1 id="写一个shell脚本"><a href="#写一个shell脚本" class="headerlink" title="写一个shell脚本"></a>写一个shell脚本</h1><p>编写</p>
<p>打开文本编辑器，新建一个文件，扩展名为sh（sh代表shell），扩展名并不影响脚本执行，见名知意就好，如果你用php写shell 脚本，扩展名就用php好了。</p>
<p>输入一些代码，第一行一般是这样：</p>
<pre><code>#!/bin/bash
#!/usr/bin/php</code></pre><p>“#!”是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行。</p>
<p>运行<br>运行Shell脚本有两种方法：</p>
<p>作为可执行程序</p>
<pre><code>chmod +x test.sh
./test.sh</code></pre><p>注意，一定要写成./test.sh，而不是test.sh，运行其它二进制的程序也一样，直接写test.sh，linux系统会去PATH里寻找有没有叫test.sh的，而只有/bin, /sbin, /usr/bin，/usr/sbin等在PATH里，你的当前目录通常不在PATH里，所以写成test.sh是会找不到命令的，要用./test.sh告诉系统说，就在当前目录找。</p>
<p>通过这种方式运行bash脚本，第一行一定要写对，好让系统查找到正确的解释器。</p>
<p>这里的”系统”，其实就是shell这个应用程序（想象一下Windows Explorer），但我故意写成系统，是方便理解，既然这个系统就是指shell，那么一个使用/bin/sh作为解释器的脚本是不是可以省去第一行呢？是的。</p>
<h1 id="作为解释器参数"><a href="#作为解释器参数" class="headerlink" title="作为解释器参数"></a>作为解释器参数</h1><p>这种运行方式是，直接运行解释器，其参数就是shell脚本的文件名，如：</p>
<pre><code>/bin/sh test.sh
/bin/php test.php</code></pre><p>这种方式运行的脚本，不需要在第一行指定解释器信息，写了也没用。</p>
]]></content>
      <categories>
        <category>基础教程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux入门-基础教程</title>
    <url>/2020/03/22/Linux%E5%85%A5%E9%97%A8-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="1-1-Linux操作系统简介"><a href="#1-1-Linux操作系统简介" class="headerlink" title="1. 1 Linux操作系统简介"></a>1. 1 Linux操作系统简介</h1><p>Linux是一套免费使用和自由传播的类Unix操作系统，是一个基于POSIX和UNIX的多用户、多任务、支持多线程和多CPU的操作系统。它能运行主要的UNIX工具软件、应用程序和网络协议。它支持32位和64位硬件。Linux继承了Unix以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。</p>
<a id="more"></a>
<p>1991年的10月5日，Linux创始人林纳斯·托瓦兹（Linus Torvalds）在comp.os.minix新闻组上发布消息，正式向外宣布Linux内核的诞生，1994年3月，Linux 1.0发布，代码量17万行，当时是按照完全自由免费的协议发布，随后正式采用GPL（General Public License的缩写，是一份GNU通用公共授权）协议。<br>Linux具有如下优点：<br>稳定、免费或者花费少<br> 安全性高<br>多任务，多用户<br>耗资源少<br>由于内核小，所以它可以支持多种电子产品，如：Android手机、PDA等。</p>
<h1 id="1-2-Linux发展趋势"><a href="#1-2-Linux发展趋势" class="headerlink" title="1. 2 Linux发展趋势"></a>1. 2 Linux发展趋势</h1><p>随着IT产业的不断发展，用户对网站体验要求也越来越高，而目前主流网站后端承载系统都是Linux系统，目前Android手机全部基于Linux内核研发。企业大数据、云存储、虚拟化等先进技术都是基于Linux系统。<br>2010年据有关权威部门统计：将来几年内我国软件行业的从业机会十分庞大，中国每年对软件人才的需求将达到50万人左右。而对于Linux 专业人才的就业前景，更是广阔；据悉在未来5-10年内 Linux 专业人才的需求将达到 120 万+！尤其是有经验的资深的Linux工程师目前非常的缺乏，薪资也是非常诱人，平均月薪都是15-20K，能力强的薪资更高。所以机会对每个人都是公平的，关键是我们每个人如何去行动，选择大于努力。</p>
<h1 id="1-3-Linux系统安装"><a href="#1-3-Linux系统安装" class="headerlink" title="1. 3      Linux系统安装"></a>1. 3      Linux系统安装</h1><p>在安装Linux系统之前，先来了解windows系统结构，windows系统一般是安装在C盘系统盘，同样Linux也有类似的系统盘（/根分区），Linux通常分区为（根分区/、swap分区），Linux系统以文件的存储方式，所有的文件都是存储在某个目录下的，类似于windows的文件夹。<br>对于文件系统的属性来说，windows文件系统类型一般是ntfs、fat32等，而Linux文件系统类型则为ext2、ext3、ext4等（文件系统：是操作系统用于明确磁盘或分区上的文件的方法和数据结构，文件系统由三部分组成：与文件管理有关软件、被管理文件以及实施文件管理所需数据结构。）<br>安装 Linux系统是每一个初学者的第一个门槛。在这个过程中间，最大的困惑莫过于给硬盘进行分区。虽然现在各种发行版本的 Linux 已经提供了友好的图形交互界面，但是很多人还是感觉无从下手。这其中的原因主要是不清楚 Linux 的分区规定。就好比如果我们了解了windows分区的规则，系统盘C、数据盘D等，就很好分区了。<br>在 Linux 中规定，每一个硬盘设备最多只能有 4个主分区（其中包含扩展分区）构成，任何一个扩展分区都要占用一个主分区号码，也就是在一个硬盘中，主分区和扩展分区一共最多是 4 个。<br>下面正式来安装Linux系统，安装系统前需要准备如下软件：<br>VMware workstation 10.0<br>CentOS 5.8 x86_i386.iso<br>安装图解如下：<br>第一步  新建虚拟机<br>第二步，选择相关选项<br>第三步选择“稍后安装操作系统”<br>第四步，选择客户机操作系统类型<br>第五步，设置虚拟机硬盘大小为20G，最低不能小于5G<br>第六步，虚拟机新建完成<br>第七步，修改虚拟机内存为512M，并添加ISO镜像<br>自此，虚拟机新建完成，接下来点击“启动此虚拟机”进行Linux系统安装，Linux系统安装图解如下：<br>第一步，进入安装界面，直接按Enter回车键即可。第二步，光盘检测，选择SKIP跳过。第三步，选择安装过程中的语言，初学者可以选择“简体中文”。第四步，选择初始化整个硬盘，清除所有数据。第五步，选择分区方式为“自定义分区“。第五步，点击“新建“-首先创建一个swap交换分区，大小为物理内存的2倍（1024M）。第六步，继续创建分区，选择“新建“，然后创建根分区/，如下图选择，大小为剩余所有空间即可。第七步，默认点击下一步，同时默认DHCP配置，时钟选择上海，去掉UTC勾，点击下一步。第八步，设置root密码，至少六位，点击下一步。第九步，系统安装包选择，这里选择“现在定制“。第十步，系统安装包选择，左侧选择“开发“—-右侧选择”开发工具“和“开发库”，语言选择“支持中文“，其他一概不选择。安装完毕会提示“reboot“，直接回车即可。</p>
<h1 id="1-4-Linux学习技巧"><a href="#1-4-Linux学习技巧" class="headerlink" title="1. 4      Linux学习技巧"></a>1. 4      Linux学习技巧</h1><p>初学者可以自己安装虚拟机，然后把linux常用命令例如cd、ls、chmod、useradd、vi等等多练习几十遍，把自己敲打命令的熟练程度提升上来。<br>然后根据文档搭建Linux下常见的各种服务（DHCP、SAMBA、DNS、Apache、Mysql等），遇到问题后可以在google搜索，搜索的时候多看几篇文章，综合最好的文章来解决问题。<br>能够熟练的搭建服务后，理解每个服务的完整配置和优化，可以拓展思维。例如LAMP，我们一般是把所有服务放在一台机器上，如果分开多台该如何部署呢？等等。<br>平时多积累shell编程，可以在网上查找前辈们写的非常好的shell，自己下载下来多练习几遍，从中吸取，不断提高。<br>建立一个自己的学习博客，把平时工作学习中的知识都记录在里面，这样也可以供别人来参考同时也能提高自己的编写文档及方案的能力。<br>通过以上学习能够满足企业的一般应有，需要达到资深级别，还需要深入学习集群架构、负载均衡、自动化运维、运维开发等知识。最后还是一句话：多练习才是硬道理！实践出真知！</p>
<h1 id="1-Linux系统篇"><a href="#1-Linux系统篇" class="headerlink" title="1.   Linux系统篇"></a>1.   Linux系统篇</h1><h1 id="2-1-Linux系统管理"><a href="#2-1-Linux系统管理" class="headerlink" title="2.1            Linux系统管理"></a>2.1            Linux系统管理</h1><p>通过前两章的学习，我们已经能够独立安装Linux系统，已经掌握了Linux学习的技巧，那接下来，我们将系统的来了解Linux系统各目录、权限及常用命令的使用。</p>
<h1 id="2-1-1-Linux目录初识"><a href="#2-1-1-Linux目录初识" class="headerlink" title="2.1. 1         Linux目录初识"></a>2.1. 1         Linux目录初识</h1><p>通过前面的学习,我们已经能够独立安装完一个linux系统，那接下来我们来熟悉一下Linux系统里面的各个目录文件夹的大致功能：<br>主要的目录树的有/、/root、/home、/usr、/bin等目录。下面是一个典型的linux目录结构如下：  </p>
<pre><code>/bin 存放必要的命令 
/boot 存放内核以及启动所需的文件
/dev 存放设备文件 
/etc 存放系统配置文件 
/home 普通用户的宿主目录，用户数据存放在其主目录中 
/lib 存放必要的运行库 
/mnt 存放临时的映射文件系统，通常用来挂载使用。
 /proc 存放存储进程和系统信息 
/root 超级用户的主目录 
/sbin 存放系统管理程序 
/tmp 存放临时文件
/usr 存放应用程序，命令程序文件、程序库、手册和其它文档。 
/var 系统默认日志存放目录</code></pre><h1 id="2-1-2-Linux必备命令"><a href="#2-1-2-Linux必备命令" class="headerlink" title="2.1. 2         Linux必备命令"></a>2.1. 2         Linux必备命令</h1><p>默认进入系统，我们会看到这样的字符:   </p>
<pre><code>[root@localhost ~]#,其中#代表当前是root用户登录，如果是$表示当前为普通用户。
我们了解linux由很多目录文件构成，那我们来学习第一个Linux命令：
cd命令， cd  /home  ；解析：进入/home目录
cd /root 进入/root目录 ；cd ../返回上一级目录;cd  ./当前目录；（.和..可以理解为相对路径；例如cd /hom/test ，cd加完整的路径，可以理解为绝对路径）
接下来继续学习更多的命令：
   ls  ./ 查看当前目录所有的文件和目录。
ls  -a 查看所有的文件，包括隐藏文件,以.开头的文件。

pwd显示当前所在的目录。
mkdir创建目录，用法mkdir  test ，命令后接目录的名称。
rmdir 删除空目录
rm 删除文件或者目录，用法 rm –rf  test.txt (-r表示递归，-f表示强制)。
cp 拷贝文件，用法,cp  old.txt  /tmp/new.txt ，常用来备份；如果拷贝目录
需要加 –r参数。

mv 重命名或者移动文件或者目录，用法, mv old.txt new.txt
touch 创建文件，用法，touch test.txt，如果文件存在，则表示修改当前文件时间。
Useradd创建用户，用法 useradd wugk ，userdel删除用户。
Groupadd创建组，用法 groupadd wugk1 ，groupdel删除组。

find查找文件或目录，用法 find  /home  -name  “test.txt”,命令格式为:
find 后接查找的目录，-name指定需要查找的文件名称，名称可以使用*表示所有。
find  /home  -name  “*.txt” ;查找/home目录下，所有以.txt结尾的文件或者目录。
vi 修改某个文件，vi有三种模式：
命令行模式、文本输入模式、末行模式。
默认vi打开一个文件，首先是命令行模式，然后按i进入文本输入模式，可以在文件里写入字符等等信息。
写完后，按esc进入命令模式，然后输入:进入末行模式，例如输入:wq表示保存退出。
如果想直接退出，不保存，可以执行:q!， q!叹号表示强制退出。
cat 查看文件内容，用法 cat test.txt 可以看到test.txt内容
more 查看文件内容，分页查看，cat是全部查看，如果篇幅很多，只能看到最后的篇幅。可以使用cat和more同时使用,例如： cat  test.txt |more 分页显示text内容，|符号是管道符，用于把|前的输出作为后面命令的输入。
echo 回显，用法 echo ok，会显示ok，输入什么就打印什么。
echo  ok  &gt; test.txt ；把ok字符覆盖test.txt内容，&gt;表示追加并覆盖的意思。
&gt;&gt;两个大于符号，表示追加，echo ok &gt;&gt; test.txt,表示向test.txt文件追加OK字符，不覆盖原文件里的内容。
初学者常见的命令就如上所示，当然还有很多深入的命令需要学习，后面的课程会讲解。</code></pre><h1 id="2-1-3-Linux用户权限管理"><a href="#2-1-3-Linux用户权限管理" class="headerlink" title="2.1. 3         Linux用户权限管理"></a>2.1. 3         Linux用户权限管理</h1><p>在Linux操作系统中，root的权限是最高的，相当于windows的administrator，拥有最高权限，能执行任何命令和操作。在系统中，通过UID来区分用户的权限级别，UID等于0，表示此用户具有最高权限，也就是管理员。其他的用户UID依次增加，通过/etc/passwd用户密码文件可以查看到每个用户的独立的UID。<br>每一个文件或者目录的权限，都包含一个用户权限、一个组的权限、其他人权限，例如下：<br>标红第一个root表示该文件所有者是root用户，第二个root代表该文件的所属的组为root组，其他用户这里默认不标出。</p>
<pre><code> [root@node1 ~]# ls -l monitor_log.sh
-rw-r–r– 1 root root 91 May  7 20:21 monitor_log.sh
[root@node1 ~]#
如果我们想改变某个文件的所有者或者所属的组，可以使用命令chown
chown  –R  test:test  monitor_log.sh即可。
每个Linux文件具有四种访问权限：可读(r)、可写(w)、可执行(x)和无权限(-)。
利用ls -l命令可以看到某个文件或目录的权限，它以显示数据的第一个字段为
 准。第一个字段由10个字符组成，如下：
    [root@node1 ~]# ls -l monitor_log.sh
-rw-r–r– 1 root root 91 May  7 20:21 monitor_log.sh
[root@node1 ~]#
    第一位表示文件类型，-表示文件，d表示目录；后面每三位为一组。
   第一组：2-4位表示文件所有者的权限，即用户user权限，简称u
   第二组：5-7位表示文件所有者所属组成员的权限，group权限，简称g
   第三组：8-10位表示所有者所属组之外的用户的权限，other权限，简称o
从上面这个文件，我们可以看出，monito_log.sh文件对应的权限为：
root用户具有读和写的权限，root组具有读的权限，其他人具有读的权限。
为了能更简单快捷的使用和熟悉权限，rwx权限可以用数字来表示，分别表示为r（4）、w（2）、x（1）。
Monitor_log.sh权限可以表示为：644
如果给某个文件授权，命令为chmod：chmod 777 monitor_log.sh</code></pre><h1 id="2-1-4-Linux网络配置管理"><a href="#2-1-4-Linux网络配置管理" class="headerlink" title="2.1. 4         Linux网络配置管理"></a>2.1. 4         Linux网络配置管理</h1><p>熟悉了常用的命令和Linux权限，那接下来如何让所在的Linux系统上网呢？管理linux服务器网络有哪些命令呢？<br>   Linux服务器默认网卡配置文件在/etc/sysconfig/network-scripts/下，命名的名称一般为:ifcfg-eth0 ifcfg-eth1 ，eth0表示第一块网卡，eth1表示第二块网卡，依次类推。一般DELL R720标配有4块千兆网卡。<br>   修改网卡的IP，可以使用命令: vi /etc/sysconfig/network-scripts/ifcfg-eth0 如果是DHCP获取的IP，默认配置如下：</p>
<pre><code># Advanced Micro Devices [AMD] 79c970 [PCnet32 LANCE]
DEVICE=eth0
BOOTPROTO=dhcp
HWADDR=00:0c:29:52:c7:4e
ONBOOT=yes
TYPE=Ethernet
如果是静态配置的IP，ifcfg-eth0网卡配置内容如下：
# Advanced Micro Devices [AMD] 79c970 [PCnet32 LANCE]
DEVICE=eth0
BOOTPROTO=static
HWADDR=00:0c:29:52:c7:4e
ONBOOT=yes
TYPE=Ethernet
IPADDR=192.168.33.10
NETMASK=255.255.255.0
GATEWAY=192.168.33.1
网卡参数详解如下：
DEVICE=eth0   #物理设备名
ONBOOT=yes   # [yes|no]（重启网卡是否激活设备）
BOOTPROTO=static #[none|static|bootp|dhcp]（不使用协议|静态分配|BOOTP协议|DHCP协议）

TYPE=Ethernet  #网卡类型
IPADDR=192.168.33.10 #IP 地址
NETMASK=255.255.255.0 #子网掩码
GATEWAY=192.168.33.1 #网关地址
网卡配置完毕，重启网卡，命令: /etc/init.d/network restart 即可。
查看ip命令：ifconfig 查看当前服务器所有网卡的IP，可以单独指定，ifconfig eth0 查看eth0的IP地址。
网卡配置完毕，如果来配置DNS，首先要知道DNS配置在哪个目录文件下，vi  /etc/resolv.conf 文件:
在该文件里面添加如下两条：
nameserver 202.106.0.20
nameserver 8.8.8.8</code></pre><p>从上到下，分别表示主DNS，备DNS。配置完毕后，不需要重启网卡,DNS立即生效。<br>可以ping <a href="http://www.ai8py.com" target="_blank" rel="noopener">www.ai8py.com</a> 看看效果:IP配置完毕后，我们可以通过远程工具来连接Linux服务器，常见的Linux远程连接工具有:putty、secureCRT（主流）、xshell、xmanger等工具。</p>
<h1 id="2-1-5-Linux软件包管理必备命令"><a href="#2-1-5-Linux软件包管理必备命令" class="headerlink" title="2.1. 5         Linux软件包管理必备命令"></a>2.1. 5         Linux软件包管理必备命令</h1><pre><code>rpm -q 包名
    选项：-q    查询
        -a    查询所有已安装的包
rpm -qi 包名
选项：
    -i  查询软件信息
    -p  查询未安装包信息
rpm -ql 包名
选项：
    -l  列表
    -p  查询未安装包信息
rpm -qR 包名
选项：
    -R  查询软件包的依赖性
    -p  查询未安装包信息
1.挂载packages目录
2.安装必须要输入包全名
rpm -ivh 包全名
选项：
    -i(install)     安装
    -v(verbose)     显示详细信息
    -h(hash)        显示进度
    --nodeps        不检测依赖性
rpm -Uvh 包名
选项：
    -U(upgrade)     升级
rpm -e 包名
选项：
    -e(erase)   卸载</code></pre><h1 id="2-Linux服务篇"><a href="#2-Linux服务篇" class="headerlink" title="2.   Linux服务篇"></a>2.   Linux服务篇</h1><h1 id="3-1-Linux服务部署"><a href="#3-1-Linux服务部署" class="headerlink" title="3.1            Linux服务部署"></a>3.1            Linux服务部署</h1><h1 id="3-1-1-构建NTP时间服务器"><a href="#3-1-1-构建NTP时间服务器" class="headerlink" title="3.1. 1         构建NTP时间服务器"></a>3.1. 1         构建NTP时间服务器</h1><p>NTP服务器是用于局域网服务器时间同步使用的，可以保证局域网所有的服务器与时间服务器的时间保持一致，某些应用对时间实时性要求高的必须统一时间。<br>互联网的时间服务器也有很多，例如ntpdate ntp.fudan.edu.cn 复旦大学的NTP免费提供互联网时间同步。<br>NTP服务器监听端口为UDP的123，那就需要在本地防火墙开启运行客户端访问123端口，vi /etc/sysconfig/iptables添加如下规则：</p>
<pre><code>-A INPUT -m state –state NEW -m udp -p udp –dport 123 -j ACCEPT
NTP时间服务器配置：
yum install ntp ntpdate -y 即可！
修改ntp.conf配置文件
cp  /etp/ntp.conf /etc/ntp.conf.bak
vi /etc/ntp.conf 只修改如下两行，把#号去掉即可！
server 127.127.1.0     # local clock
fudge  127.127.1.0 stratum 10
以守护进程启动ntpd
/etc/init.d/ntpd start 即可
（注意*： ntpd启动后，客户机要等几分钟再与其进行时间同步，否则会提示“no server suitable for synchronization found”错误。）
配置时间同步客户机
crontab -e
增加一行，在每天的6点10分与时间同步服务器进行同步
10 06 * * * /usr/sbin/ntpdate ntp-server的ip &gt;&gt;/usr/local/logs/crontab/ntpdate.log
备注：如果客户机没有ntpdate，可以yum –y install ntp 即可！
以下是ntp服务器配置文件内容(局域网NTP，如果需要跟外网同步，添加外网server即可)
driftfile /var/lib/ntp/drift
restrict default kod nomodify notrap nopeer noquery
restrict -6 default kod nomodify notrap nopeer noquery
restrict 127.0.0.1
restrict -6 ::1
server  127.127.1.0     # local clock
fudge   127.127.1.0 stratum 10
includefile /etc/ntp/crypto/pw
keys /etc/ntp/keys
下面是参数详解：

restrict default ignore    # 关闭所有的 NTP 要求封包
restrict 127.0.0.1    # 开启内部递归网络接口 lo
restrict 192.168.0.0 mask 255.255.255.0 nomodify    #在内部子网里面的客户端可以进行网络校时，但不能修改NTP服务器的时间参数。
server 198.123.30.132    #198.123.30.132作为上级时间服务器参考
restrict 198.123.30.132    #开放server 访问我们ntp服务的权限
driftfile /var/lib/ntp/drift    在与上级时间服务器联系时所花费的时间，记录在driftfile参数后面的文件内
broadcastdelay 0.008    #广播延迟时间
 自此NTP服务搭建完毕，然后在所有客户端crontab里面添加如下语句：
0  0   *  *  * /usr/sbin/ntpdate  10.0.0.155 &gt;&gt;/data/logs/ntp.log 2&gt;&amp;1</code></pre><h1 id="3-1-2-构建DHCP服务器"><a href="#3-1-2-构建DHCP服务器" class="headerlink" title="3.1. 2         构建DHCP服务器"></a>3.1. 2         构建DHCP服务器</h1><p>DHCP(Dynamic Host Configuration Protocol，动态主机配置协议)是一个局域网的网络协议，使用UDP协议工作，主要用途：给内部网络或网络服务供应商自动分配IP地址，DHCP有3个端口，其中UDP67和UDP68为正常的DHCP服务端口，分别作为DHCP Server和DHCP Client的服务端口。<br>DHCP可以部署在服务器、交换机或者服务器，可以控制一段IP地址范围，客户机登录服务器时就可以自动获得DHCP服务器分配的IP地址和子网掩码。其中DHCP所在服务器的需要安装TCP/IP协议，需要设置静态IP地址、子网掩码、默认网关。<br>正式安装DHCP服务：<br>Yum  install  dhcp dhcp-devel –y 即可，然后修改DHCP /etc/dhcpd.conf配置文件内容如下：</p>
<pre><code>ddns-update-style interim;
ignore client-updates;
next-server  192.168.0.79;
filename “pxelinux.0”;
allow booting;
allow bootp; 
subnet 192.168.0.0 netmask 255.255.255.0 {
# — default gateway
option routers          192.168.0.1;
option subnet-mask      255.255.252.0;
#   option nis-domain       “domain.org”;
#  option domain-name “192.168.0.10”;
#   option domain-name-servers  192.168.0.11;
#   option ntp-servers      192.168.1.1;
#   option netbios-name-servers  192.168.1.1;
# — Selects point-to-point node (default is hybrid). Don’t change this unless
# — you understand Netbios very well
#   option netbios-node-type 2;
range  dynamic-bootp  192.168.0.100 192.168.0.200;
host ns {
hardware ethernet  00:1a:a0:2b:38:81;
fixed-address 192.168.0.101;}
}
参数解析如下：

选    项    解    释

ddns-update-style interim|ad-hoc|none     参数用来设置DHCP服务器与DNS服务器的动态信息更新模式：interim为DNS互动更新模式，ad-hoc为特殊DNS更新模式，none为不支持动态更新模式。
next-server ip    pxeclient远程安装系统，指定tftp server 地址
filename    开始启动文件的名称，应用于无盘安装，可以是tftp的相对或绝对路径  
ignore client-updates    为忽略客户端更新
subnet-mask    为客户端设定子网掩码
option routers    为客户端指定网关地址
domain-name    为客户端指明DNS名字
domain-name-servers    为客户端指明DNS服务器的IP地址
host-name    为客户端指定主机名称
broadcast-address    为客户端设定广播地址
ntp-server    为客户端设定网络时间服务器的IP地址
time-offset    为客户端设定格林威治时间的偏移时间，单位是秒
注意如上配置，需要修改成对应服务器网段IP，然后重启DHCP服务，/etc/init.d/dhcpd restart即可。
客户端要从这个DHCP服务器获取IP，需要做简单的设置，如果是linux需要把/etc/sysconfig/network-scritps/ifcfg-eth0里BOOTPROTO相改成dhcp即可，windows机器的话，需要修改本地连接，把它设置成自动获取IP即可。
BOOTPROTO=dhcp</code></pre><h1 id="3-1-3-搭建Samba服务器"><a href="#3-1-3-搭建Samba服务器" class="headerlink" title="3.1. 3         搭建Samba服务器"></a>3.1. 3         搭建Samba服务器</h1><p>Samba是在Linux和UNIX系统上实现SMB协议的一个免费软件，由服务器及客户端程序构成，<br>SMB（Server Messages Block，信息服务块）是一种在局域网上共享文件和打印机的一种通信协议，它为局域网内的不同计算机之间提供文件及打印机等资源的共享服务。<br>SMB协议是客户机/服务器型协议，客户机通过该协议可以访问服务器上的共享文件系统、打印机及其他资源。通过设置“NetBIOS over TCP/IP”使得Samba不但能与局域网络主机分享资源，还能与全世界的电脑分享资源。<br>安装SAMBA服务器：<br>Yum install  samba –y<br>安装完毕，然后做如下设置（过滤#号行、空行如下命令）<br>cp /etc/samba/smb.conf /etc/samba/smb.conf.bak ;egrep -v “#|^$” /etc/samba/smb.conf.bak |grep -v “^;” &gt;/etc/samba/smb.conf<br>查看smb.conf配置文件如下：</p>
<pre><code>[global]
        workgroup = MYGROUP
        server string = Samba Server Version %v
        security = share
        passdb backend = tdbsam
        load printers = yes
        cups options = raw

[temp]
     comment=Temporary file space
     path=/tmp
     read only=no
     public=yes

[data]
     comment=Temporary file space
     path=/data
     read only=no
     public=yes
根据需求修改之后重启服务：
[root@node1 ~]# /etc/init.d/smb restart
Shutting down SMB services:                                [FAILED]
Shutting down NMB services:                                [FAILED]
Starting SMB services:                                     [  OK  ]
Starting NMB services:                                     [  OK  ]


workgroup =    WORKGROUP 设Samba Server 所要加入的工作组或者域。
server string = Samba Server Version %v    Samba Server 的注释，可以是任何字符串，也可以不填。宏%v表示显示Samba的版本号。




security = user    1.share：用户访问Samba Server不需要提供用户名和口令, 安全性能较低。
2. user：Samba Server共享目录只能被授权的用户访问,由Samba Server负责检查账号和密码的正确性。账号和密码要在本Samba Server中建立。
3. server：依靠其他Windows NT/2000或Samba Server来验证用户的账号和密码,是一种代理验证。此种安全模式下,系统管理员可以把所有的Windows用户和口令集中到一个NT系统上,使用Windows NT进行Samba认证, 远程服务器可以自动认证全部用户和口令,如果认证失败,Samba将使用用户级安全模式作为替代的方式。
4. domain：域安全级别,使用主域控制器(PDC)来完成认证。
comment = test    是对该共享的描述，可以是任意字符串。
path = /home/test    共享目录路径
browseable= yes/no     用来指定该共享是否可以浏览。
writable = yes/no    writable用来指定该共享路径是否可写。
available = yes/no    available用来指定该共享资源是否可用
admin users = admin    该共享的管理者
valid users = test    允许访问该共享的用户
invalid users = test    禁止访问该共享的用户
write list = test    允许写入该共享的用户
public = yes/no    public用来指定该共享是否允许guest账户访问。
 在浏览器里面访问方式为：\\192.168.33.10 （SMB文件共享服务端IP），如何没有权限访问，需要注意防火墙和selinux设置，可以使用如下命令关闭：
/etc/init.d/iptables stop ;sed  –i   ‘/SELINUX/s/enforcing/disabled’  /etc/sysconfig/selinux</code></pre><h1 id="3-1-4-搭建NFS服务器"><a href="#3-1-4-搭建NFS服务器" class="headerlink" title="3.1. 4         搭建NFS服务器"></a>3.1. 4         搭建NFS服务器</h1><p>NFS 是Network File System的缩写，即网络文件系统。一种使用于分散式文件系统的协定，由Sun公司开发，于1984年向外公布。功能是通过网络让不同的机器、不同的操作系统能够彼此分享个别的数据，让应用程序在客户端通过网络访问位于服务器磁盘中的数据，是在类Unix系统间实现磁盘文件共享的一种方法。<br>NFS在文件传送或信息传送过程中依赖于RPC协议。RPC，远程过程调用 (Remote Procedure Call) 是能使客户端执行其他系统中程序的一种机制。NFS本身是没有提供信息传输的协议和功能的。<br>NFS应用场景，常用于高可用文件共享，多台服务器共享同样的数据，可扩展性比较差，本身高可用方案不完善，取而代之的数据量比较大的可以采用MFS、TFS、HDFS等等分布式文件系统。<br>NFS安装配置：</p>
<pre><code>Yum  install nfs*  portmap  -y </code></pre><p>安装成功即可。NFS安装完毕，需要创建共享目录，共享目录在/etc/exports文件里面配置，可配置参数如下：</p>
<pre><code>/data/      192.168.33.11(rw,sync,no_hide,no_all_squash)</code></pre><p>在配置文件中添加如上一行，然后重启Portmap，NFS服务即可，/etc/init.d/portmap restart ;/etc/init.d/nfs restart<br>第一列/data/表示需要共享的目录。<br>IP表示允许哪个客户端访问。<br>IP后括号里的设置表示对该共享文件的权限。</p>
<pre><code>ro                      只读访问
rw                      读写访问
sync                    所有数据在请求时写入共享
hide                    在NFS共享目录中不共享其子目录
no_hide                 共享NFS目录的子目录
all_squash              共享文件的UID和GID映射匿名用户anonymous，适合公用目录。
no_all_squash           保留共享文件的UID和GID（默认）
root_squash             root用户的所有请求映射成如anonymous用户一样的权限（默认）
no_root_squas           root用户具有根目录的完全管理访问权限Linux客户端，如何想使用这个NFS文件系统，需要在客户端挂载，挂载命令为：
Mount –t  nfs  192.168.33.10:/data/    /mnt 即可。如果有报错根据错误信息排查。常见问题有rpc服务没有启动、防火墙没关闭、selinux未关闭等问题。（拓展* 有兴趣的童鞋可以研究MFS（分布式文件系统）。）</code></pre><h1 id="3-1-5-搭建FTP服务器"><a href="#3-1-5-搭建FTP服务器" class="headerlink" title="3.1. 5         搭建FTP服务器"></a>3.1. 5         搭建FTP服务器</h1><p>FTP 是文件传输协议，正是由于这种协议使得主机间可以共享文件。 FTP 使用TCP 生成一个虚拟连接用于控制信息，然后再生成一个单独的 TCP 连接用于数据传输。<br>vsftpd是一款在Linux发行版中最主流的FTP服务器程序；特点是小巧轻快，安全易用；能让其自身特点得发发挥和掌握。<br>目前在开源操作系统中常用的FTP服务器程序主要有vsftpd、ProFTPD、PureFTPd和wuftpd等，这么多FTP服务器程序，关键在于自己熟练哪一个就使用哪一个。今天我们来研究一下VSFTPD简单安装及使用。安装命令: </p>
<pre><code>yum  install vsftpd*  -y修改配置文件如下：
#vsftpd config 2014 by wugk
anonymous_enable=NO    //禁止匿名用户访问
local_enable=YES  //允许本地用户登录FTP
write_enable=YES   //运行用户在FTP目录有写入的权限
local_umask=022   //设置本地用户的文件生成掩码为022，默认是077
dirmessage_enable=YES //激活目录信息,当远程用户更改目录时,将出现提示信息
xferlog_enable=YES   //启用上传和下载日志功能
connect_from_port_20=YES  //启用FTP数据端口的连接请求
xferlog_std_format=YES  //是否使用标准的ftpd xferlog日志文件格式
listen=YES  //使vsftpd处于独立启动监听端口模式
pam_service_name=vsftpd //设置PAM认证服务配置文件名称，文件存放在/etc/pam.d/目录
userlist_enable=YES   //用户列表中的用户是否允许登录FTP服务器,默认是不允许
tcp_wrappers=YES    //使用tcp_wrqppers作为主机访问控制方式</code></pre><p>1)    第一种方法就是使用系统用户登录FTP，但是也是比较危险的，先测试系统用户登录FTP，在Linux系统上创建useradd  test 用户，并为其设置名，然后在xp客户端打开我的电脑资源里面访问 <a href="ftp://192.168.33.10，输入用户名和密码即可访问，进行创建和删除操作。">ftp://192.168.33.10，输入用户名和密码即可访问，进行创建和删除操作。</a><br>2)    第二种方法比较安全，配置相对复杂一点，就是使用vsftpd虚拟用户登录FTP服务器进行常见的操作。<br>Ø       首先安装FTP 虚拟用户需要用到的软件及认证模块</p>
<pre><code>yum install pam* db4* –skip-broken –y</code></pre><p>创建并生成vsftpd数据库文件vi /etc/vsftpd/ftpusers.txt，内容如下：<br>第一行为FTP虚拟用户，登录用户名，第二行为密码，第三行为用户名，依次类推。</p>
<pre><code>wugk
1
wugk1
1
Ø       生成数据库文件命令：
db_load -T -t hash -f /etc/vsftpd/ftpusers.txt /etc/vsftpd/vsftpd_login.db
chmod 700 /etc/vsftpd/vsftpd_login.db
Ø       配置PAM验证文件：
在配置文件vi /etc/pam.d/vsftpd 行首加入如下两行认证语句：（如果是32位，lib64需改成lib，如果RedHat，加入的语句不一样，需注意）
auth    sufficient      /lib64/security/pam_userdb.so     db=/etc/vsftpd/vsftpd_login
account sufficient      /lib64/security/pam_userdb.so      db=/etc/vsftpd/vsftpd_login
Ø       创建vsftpd映射本地用户:
所有的FTP虚拟用户需要使用一个系统用户，这个系统用户不需要密码，也不需要登录。主要用来做虚拟用户映射使用。
useradd  –d /home/ftpuser –s /sbin/nologin ftpuser
Ø       修改完整版配置文件内容如下：
anonymous_enable=NO
local_enable=YES
write_enable=YES
local_umask=022
dirmessage_enable=YES
xferlog_enable=YES
connect_from_port_20=YES
xferlog_file=/var/log/vsftpd.log
xferlog_std_format=YES
ascii_upload_enable=YES
ascii_download_enable=YES
listen=YES
guest_enable=YES
guest_username=ftpuser
pam_service_name=vsftpd
user_config_dir=/etc/vsftpd/vsftpd_user_conf
virtual_use_local_privs=YES

   保存重启,/etc/init.d/vsftpd restart 即可使用虚拟用户登录，这时候所有的虚拟用户共同使用/home/ftpuser目录上传下载，如果想使用自己独立的目录，可以在/etc/vsftpd/vsftpd_user_conf目录创建各自的配置文件，如给wugk创建独立的配置文件：
vi /etc/vsftpd/vsftpd_user_conf/wugk ，内容如下，建立自己的FTP目录。
local_root=/home/ftpsite/wugk
write_enable=YES
anon_world_readable_only=YES
anon_upload_enable=YES
anon_mkdir_write_enable=YES
anon_other_write_enable=YES</code></pre><p> 重启，使用客户端登录FTP，测试即可。关于FTP讲解就到此，windows还可以使用Server-U来搭建FTP服务器端，有兴趣的童鞋可以研究一下。</p>
<h1 id="FTP主被动模式"><a href="#FTP主被动模式" class="headerlink" title="FTP主被动模式"></a>FTP主被动模式</h1><h1 id="FTP主动模式："><a href="#FTP主动模式：" class="headerlink" title="FTP主动模式："></a>FTP主动模式：</h1><p>客户端从一个任意的非特权端口N（N&gt;1024）连接到FTP服务器的port 21命令端口。然后客户端开始监听端口N+1，并发送FTP命令“port N+1”到FTP服务器。接着服务器会从它自己的数据端口（20）连接到客户端指定的数据端口（N+1）。</p>
<h1 id="FTP被动模式："><a href="#FTP被动模式：" class="headerlink" title="FTP被动模式："></a>FTP被动模式：</h1><p>客户端从一个任意的非特权端口N（N&gt;1024）连接到FTP服务器的port 21命令端口。然后客户端开始监听端口N+1，同时客户端提交 PASV命令。服务器会开启一个任意的非特权端口（P &gt;1024），并发送PORT P命令给客户端。然后客户端发起从本地端口N+1到服务器的端口P的连接用来传送数据。</p>
]]></content>
      <categories>
        <category>基础教程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Flask-PYTHON Web框架</title>
    <url>/2020/03/21/Flask-PYTHON-Web%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Flask是一个基于Python开发并且依赖jinja2模板和Werkzeug WSGI服务的一个微型框架，</p>
<a id="more"></a>
<p>对于Werkzeug本质是Socket服务端，其用于接收http请求并对请求进行预处理，然后触发Flask框架，开发人员基于Flask框架提供的功能对请求进行相应的处理，并返回给用户，如果要返回给用户复杂的内容时，需要借助jinja2模板来实现对模板的处理，即：将模板和数据进行渲染，将渲染后的字符串返回给用户浏览器。</p>
<h1 id="学习资源"><a href="#学习资源" class="headerlink" title="学习资源"></a>学习资源</h1><p>Flask官网：<a href="http://flask.pocoo.org/" target="_blank" rel="noopener">http://flask.pocoo.org/</a><br>Flask中文翻译：<a href="http://dormousehole.readthedocs.io/en/latest/" target="_blank" rel="noopener">http://dormousehole.readthedocs.io/en/latest/</a><br>Jinja文档：<a href="http://jinja.pocoo.org/docs/dev/templates/" target="_blank" rel="noopener">http://jinja.pocoo.org/docs/dev/templates/</a><br>Jinja中文文档：<a href="http://docs.jinkan.org/docs/jinja2/" target="_blank" rel="noopener">http://docs.jinkan.org/docs/jinja2/</a></p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>本示例基于window系统。<br>1.安装pip和virtualenv（若以安装忽略）：</p>
<pre><code>easy_install pip
easy_install virtualenv</code></pre><p>2.创建项目目录firstPython。目录下执行cmd，</p>
<pre><code>virtualenv flask</code></pre><p>  这里会在当前目录下生成flask文件夹，里边自动添加了一些python相关的包和解释器等文件。<br>3.安装flask和扩展包</p>
<pre><code>flask\Scripts\pip install flask
flask\Scripts\pip install flask-login
flask\Scripts\pip install flask-openid
flask\Scripts\pip install flask-sqlalchemy
flask\Scripts\pip install sqlalchemy-migrate
flask\Scripts\pip install flask-whooshalchemy
flask\Scripts\pip install flask-wtf
flask\Scripts\pip install flask-babel
flask\Scripts\pip install flup
flask\Scripts\pip install --no-deps lamson chardet flask-mail</code></pre><p>  上面是一些常用扩展包，目前用不上，可以只引用flask。注意，执行的pip路径是flask\Scripts\pip，这样调用本工程下的pip。</p>
<h1 id="启动服务-测试"><a href="#启动服务-测试" class="headerlink" title="启动服务 测试"></a>启动服务 测试</h1><p>1.创建hello.py:</p>
<pre><code>from flask import Flask
app = Flask(name)
@app.route(&quot;/&quot;)
def hello():
    return &quot;Hello World!&quot;
if name == &#39;main&#39;:
   app.run()</code></pre><p>2.运行hello.py:<br>当前目录下cmd：</p>
<pre><code>python hello.py</code></pre><p>成功后访问地址默认端口5000.显示Hello world！</p>
]]></content>
      <categories>
        <category>Web 框架</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Django-PYTHON Web框架</title>
    <url>/2020/03/21/Django-PYTHON-Web%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>本章开始不再介绍 Python 标准库，如有需求可编辑基础技术发送至邮箱或者添加好友回复即可。开始介绍一个著名的 Web 框架：Django。</p>
<a id="more"></a>
<p>首先简要介绍什么是 Web 框架，接着介绍使用 Django 开发应用。从基础开始介绍 Django，并开发一个“Hello World”应用。接着逐步深入，介绍开发实际应用时所要了解的内容。这个路线图也组成了本章的架构： 首先夯实基础；然后介绍中级应用，这个应用会涉及Twitter、电子邮件和 OAuth（OAuth 是一个开放的授权协议，用于通过应用编程接口[API]访问数据）。<br>本章旨在介绍一款工具，Python 开发者每天都会用这款工具解决实际问题。通过本章， 读者会学到一些技能和足够的知识，来通过 Django 构建更复杂的工具。读者可以带着这些技能去学习任何其他Python Web 框架。首先，了解什么是 Web 框架。</p>
<h1 id="Web-框架"><a href="#Web-框架" class="headerlink" title="Web 框架"></a>Web 框架</h1><p>Django 是由一个开发团队作为单个突出创建的，但并不是所有框架都遵循这种哲学。以TurboGears 为例，这是一个非常优秀的全栈系统，由分散在全世界的开发者开发，其作为胶水代码，将栈中其他独立的组件组合起来，如ToscaWidgets（高级 Web 部件，它可利用多种JavaScript 框架，如 Ex1tJs、jQuery 等）、SQLAlchemy（ORM）、Pylons（Web 服务器），还有Genshi（模板化）。遵循这种架构样式的框架能提供很好的灵活性，用户可以选择不同的模板系统、JS 库、生成原始 SQL 语句的工具，以及不同的 Web 服务器。只须牺牲一点一致性和放弃单一工具的追求。但对框架的使用也许与之前的方式没什么区别。<br>Pyramid 是另外一个非常著名的 Web 框架，这是 repoze.bfg（或简称 BFG）和 Pylons 的继承者。Pyramid 的方式更加简单，它只提供一些基础功能，如URL 分派、模板化、安全和一些资源。如果需要其他功能，必须手动添加。这种极简的方式带来的好处就是 Pyramid 拥有完整的测试和文档，以及从Pylons 和BFG 社区继承的用户，让Pyramid 成为今日Python Web 框架中有力的竞争者。<br>如果读者刚接触到 Python，可能会了解 Rails 或 PHP，这两者原先只想将语言嵌入到HTML 中，后来扩展成一个庞大框架。Python 的好处就是不必局限于“一种语言，一种框架” 的形式。从 Python 中可以选择许多框架，就如同本章起始处的引用所说的那样。Web 服务器网关接口（WSGI）标准的建立加速了 Web 框架的发展。Python WSGI 由PEP 333 定义，参见：[<a href="http://python.org/dev/peps/pep-0333]。" target="_blank" rel="noopener">http://python.org/dev/peps/pep-0333]。</a><br>如果读者还不了解 WSGI，这里有必要简要说明一下。WSGI 不是实际的代码或 API，而定义了一系列接口，让 Web 框架的开发者无须为框架创建自定义 Web 服务器，也让应用程序开发者可以自行选择 Web 服务器。有了WSGI，应用开发者就可以方便地切换（或开发新的）WSGI 兼容的服务器，而无须担心需要改变应用代码。<br>当热情的 Python 开发者不满足已有的框架时，他们就会创建一个新框架。Python 中 Web 框架的数目比关键字的数目还多。其他框架还包括 web2py、web.py、Tornado、Diesel 和 Zope。可以在 Python 官网的维基页面[<a href="http://wiki.python.org/moin/WebFrameworks]" target="_blank" rel="noopener">http://wiki.python.org/moin/WebFrameworks]</a> 来了解这些框架。<br>回到正文，现在在这些 Web 开发的相关知识的基础上来学习Django。</p>
<h1 id="Django-简介"><a href="#Django-简介" class="headerlink" title="Django 简介"></a>Django 简介</h1><p>Django 自称是“能够很好地应对应用上线期限的 Web 框架”。其最初在 21 世纪初发布， 由 Lawrence Journal-Wor ld 报业的在线业务的 Web 开发者创建。2005 年正式发布，引入了以“新闻业的时间观开发应用”的方式。本章中我们会使用   Django  开发一个简单的博客应用， 下一章会用 Google App Engine 开发相同的应用，比较两者来看 Django 的开发速度（这里的博客比较简单，读者需要自行完善）。尽管会直接给出这个例子，但在介绍的过程中仍然会详细解释示例。</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>在介绍 Django 开发之前，首先安装必需的组件，这包括依赖组件和 Django 本身。<br>预备条件<br>在安装 Django 之前，必须先安装 Python。由于读者已经读到本书第 10 章了，因此假设已经安装了 Python。大多数兼容POSIX 的系统（Mac  OS X、Linux、*BSD）都已经安装了Python。只有微软 Windows 需要自行下载并安装 Python。<br>Apache 是 Web 服务器中的王者，因此大多数部署都会使用这款服务器。Django 团队建议使用 mod_wdgi 这个Apache 模块，并提供了安装指南：[<a href="http://docs.djangoproject.com/en/dev/topics/install/]" target="_blank" rel="noopener">http://docs.djangoproject.com/en/dev/topics/install/]</a></p>
<pre><code>#install-apache-and-mod-wsgi</code></pre><p>同时也提供了完整的开发文档，参见  [<a href="http://docs.djangoproject.com/en/dev/howto/deployment/modwsgi/]。还有一份更好的文档，其中介绍了使用一个" target="_blank" rel="noopener">http://docs.djangoproject.com/en/dev/howto/deployment/modwsgi/]。还有一份更好的文档，其中介绍了使用一个</a>   Apache  实例来持有多个   Django  Web  站点（项目），参见   [<a href="http://forum.webfaction.com/viewtopic.php?id=3646]" target="_blank" rel="noopener">http://forum.webfaction.com/viewtopic.php?id=3646]</a> 。如果想了解  mod_python，只能在老的  Django  安装包或在mod_wsgi 成为标准之前的一些操作系统的发行版中寻找。官方已经不支持 mod_python（实际上，从Django 1.5 开始，就移除了 mod_python）。<br>在结束对Web服务器的讨论之前 ①，还需要提醒读者，在生产环境的服务器中并不是一定要使用Apache，还可以有其他选择，其中有些内存占用量更少，速度更快。也许其中一个就更适合你的应用。可以在[<a href="http://code.djangoproject.com/wiki/ServerArrangements]中查找符合要求的Web服务器。" target="_blank" rel="noopener">http://code.djangoproject.com/wiki/ServerArrangements]中查找符合要求的Web服务器。</a><br>Django 需要用到数据库。当前的标准版 Django 只可运行基于 SQL 的关系数据库管理系统（RDBMS）。用户主要使用 4 种数据库，分别是 PostgreSQL、MySQL、Oracle 和 SQLite。其中最容易设置的是 SQLite。另外，SQLite 是这 4 个当中唯一一个无须部署数据库服务器的，所以使用起来也是最简单的。当然，简单并不代表无能，SQLite  功能和另外三个一样强大。<br>① 除非到了开发阶段，否则无需 Web 服务器，因此可以在后面安装。Django 自带了开发服务器（刚刚已经看到），可以用于创建和测试应用。<br>为什么 SQLite 很容易设置？SQLite 数据库适配器是所有 Python 版本中自带的（从 2.5 开始）。注意，这里说的是适配器。有些 Python 发行版自带了 SQLite 本身，有些会使用系统上安装的 SQLite。而其他东西则需要手动下载和安装。<br>Django 支持众多关系数据库，SQLite 只是其中一种，所以如果不喜欢 SQLite，可以使用其 他数据库，特别是如果公司已经使用了某一款基于服务器的数据库。关于 Django 和数据库安装的更多内容，可以参考 [<a href="http://docs.djangoproject.com/en/dev/topics/install/#data-base-installation]。" target="_blank" rel="noopener">http://docs.djangoproject.com/en/dev/topics/install/#data-base-installation]。</a><br>最近还有快速发展的非关系数据库（NoSQL）。大概这是因为这种类型的系统提供了额外的可扩展性，能面对不断增长的数据量。如果处理像 Facebook、Twitter 或类似服务那样的海量数据，关系数据库需要手动分区（切分）。如果需要使用 NoSQL 数据库，如 MongoDB 或 Google App Engine 的原生Datastore，可以尝试 Django-nonrel，这样用户就可以选择使用关系或非关系数据库。（需要说明一下，Goolge App Engine 也有一个关系数据库（兼容MySQL），即   Google Cloud SQL）。<br>可以从 [<a href="http://www.allbuttonspressed.com/projects/django-nonrel]" target="_blank" rel="noopener">http://www.allbuttonspressed.com/projects/django-nonrel]</a> 下载Django-nonrel，以及其适配器，参见 [<a href="https://github.com/FlaPer87/django-mongodb-engine]（Django" target="_blank" rel="noopener">https://github.com/FlaPer87/django-mongodb-engine]（Django</a> 和MongoDB），或者 [<a href="http://www.allbuttonspressed.com/projects/djangoappengine]（Django" target="_blank" rel="noopener">http://www.allbuttonspressed.com/projects/djangoappengine]（Django</a> 和Google App Engine 的 Datastore）。在本书编写时，由于 Django-nonrel 是Django 的分支，因此只能安装其中一个。主要原因是因为需要在开发环境和生产环境中使用相同的版本。如同在 <a href="http://www" target="_blank" rel="noopener">http://www</a>. allbuttonspressed.com/projects/django-nonrel 上说的那样，“（Django-nonrel）只对 Django 进行了一丁点修改（可能少于 100 行）”。Django-nonrel 可作为压缩文件下载，所以直接解压它， 在对应的目录中执行下面的命令。</p>
<pre><code>$ sudo python setup.py install</code></pre><p>如果下载Django 压缩包，其安装方法完全相同（如下所示），所以完全可以跳过下一节， 直接开始学习教程。</p>
<h1 id="安装-Django"><a href="#安装-Django" class="headerlink" title="安装 Django"></a>安装 Django</h1><p>有多种方法可以安装 Django，下面对这些安装方法按难易程度排序，越靠前的越简单。<br>Python 包管理器<br>操作系统包管理器<br>官方发布的压缩包<br>源码库<br>最简单的下载和安装方式是使用 Python 包管理工具，如 Setuptools 中的 easy_install<br>（[<a href="http://packages.python.org/distribute/easy_install.html]），或" target="_blank" rel="noopener">http://packages.python.org/distribute/easy_install.html]），或</a>    pip（[<a href="http://pip.openplans.org]），所有平台上都可使用这两个工具。对于">http://pip.openplans.org]），所有平台上都可使用这两个工具。对于</a> Windows 用户，使用 Setuptools 时需要将 easy_install.exe<br>文件放在Python 安装目录下的 Scripts 文件夹中。此时只须在 DOS 命令行窗口中使用一条命令就能安装 Django。</p>
<pre><code>C:\WINDOWS\system32&gt;easy_install django 
Searching for django
Reading http://pypi.python.org/simple/django/ 
Reading http://www.djangoproject.com/
Best match: Django 1.2.7
Downloading http://media.djangoproject.com/releases/1.2/Django- 1.2.7.tar.gz
Processing Django-1.2.7.tar.gz
. . .
Adding django 1.2.7 to easy-install.pth file
Installing django-admin.py script to c:\python27\Scripts
Installed c:\python27\lib\site-packages\django-1.2.7-py2.7.egg 
Processing dependencies for django
Finished processing dependencies for django</code></pre><p>为了无须输入easy_install.exe的全路径，建议将C:\Python2x\Scipts添加到PATH环境变量 ① 中，其中 2.x根据Python的版本来决定。如果使用的是POSIX系统，easy_install会安装到众所周知的/usr/bin或/usr/local/bin中，所以无须再将其添加到PATH中，但可能需要使用sudo命令来将软件安装到一些典型的系统目录中，如/usr/local。命令如下所示。</p>
<pre><code>$ sudo easy_install django</code></pre><p>pip 的命令（不使用 virtuabanv）如下所示。</p>
<pre><code>$ pip install django ＃sudo</code></pre><p>只有在安装到需要超级用户权限的路径中时才会用到sudo；如果安装到用户目录中则不需要。这里还建议使用“容器”环境，如 virtualenv。使用 virtualenv 可以同时安装多个版本的Python、Django、数据库等。每个环境在独立的容器中运行，可以自由创建、管理、执行、销毁。关于 virtualenv 的更多内容可以参见 [<a href="http://pypi.python.org/pypi/virtualenv]。" target="_blank" rel="noopener">http://pypi.python.org/pypi/virtualenv]。</a><br>另一种安装 Django 的方式是使用操作系统自带的包管理器（前提是系统有包管理器）。一般仅限于 POSIX 类的操作系统，如 Linux 和 Mac OS X。操作命令如下所示。</p>
<pre><code>(Linux) $ sudo COMMAND install django 
(Mac OS X) $ sudo port install django</code></pre><p>① Windows 系统用户可以修改PATH 环境变量。首先右击“我的电脑”，接着选择“属性”。在弹出的对话框中，选择“高级”标签，最后单击“环境变量”按钮。<br>对于 Linux 用户，COMMAND 是对应发行版的包管理器，如 apt-get、yum、aptitude 等。可以从 [<a href="http://docs.djangoproject.com/en/dev/misc/distributions]" target="_blank" rel="noopener">http://docs.djangoproject.com/en/dev/misc/distributions]</a> 中找到不同发行版的安装指导。<br>除了上面提到的方法之外，还可以从 Django 网站直接下载并安装原始发布的压缩包。下载并解压后，就可以使用普通的命令进行安装。</p>
<pre><code>$ sudo python setup.py install</code></pre><p>在 [<a href="http://docs.djangoproject.com/en/dev/topics/install/#installing-an-official-release]" target="_blank" rel="noopener">http://docs.djangoproject.com/en/dev/topics/install/#installing-an-official-release]</a> 中可以找到更详细的安装指南。<br>专业开发者可能更喜欢从 Subversion 源码树中自行获取最新的源码。关于这种安装过程，可以参考 [<a href="http://docs.djangoproject.com/en/dev/topics/install/#installing-the-development-version]。" target="_blank" rel="noopener">http://docs.djangoproject.com/en/dev/topics/install/#installing-the-development-version]。</a><br>最后，[<a href="http://docs.djangoproject.com/en/dev/topics/install/#install-the-django-code]" target="_blank" rel="noopener">http://docs.djangoproject.com/en/dev/topics/install/#install-the-django-code]</a> 包含了所有的安装指南。<br>下一步是设置服务器，确保所有组件安装完毕并能正常工作。但在此之前，先介绍一些基本的 Django 概念、项目（project）和应用（app）。</p>
<h1 id="项目和应用"><a href="#项目和应用" class="headerlink" title="项目和应用"></a>项目和应用</h1><p>Django 中的项目和应用是什么？简单来说，可以认为项目是一系列文件，用来创建并运行一个完整的 Web 站点。在项目文件夹下，有一个或多个子文件夹，每个子文件夹有特定的功能，称为应用。应用并不一定要位于项目文件夹中。应用可以专注于项目某一方面的功能， 或可以作为通用组件，用于不同的项目。应用是一个具有特定功能的子模块，这些子模块组合起来就能完成 Web  站点的功能。如管理用户/读者反馈、更新实时信息、处理数据、从站点聚合数据等。<br>从Pinax 平台上能找到比较著名的可重用的 Django 应用。其中包括（但不限于）验证模块（OpenID 支持、密码管理等）、消息处理（E-mail 验证、通知、用户间联系、兴趣小组、主题讨论等），以及其他功能，如项目管理、博客、标签、导入联系人等。关于 Pinax 的更多内容可以访问其网站：[<a href="http://pinaxproject.com]。">http://pinaxproject.com]。</a><br>项目和应用的概念简化了可插拔的使用方式，同时也强烈鼓励了敏捷设计和代码重用。现在知道了什么是项目和应用，下面开始创建一个项目。</p>
<h1 id="在-Django-中创建项目"><a href="#在-Django-中创建项目" class="headerlink" title="在 Django 中创建项目"></a>在 Django 中创建项目</h1><p> Django 带有一个名为 django-admin.py 的工具，它可以简化任务，如创建前面提到的项目目录。在 POSIX 平台上，它一般会安装到/usr/local/bin、/usr/bin 这样的目录中。如果使用的是 Windows 系统，它会安装到 Scripts 文件夹下，该文件夹位于 Python 安装目录下，如 C:\Python37\Scripts 。无论是 POSIX 还是 Windows 系统， 都应该确保django-admin.py 位于 PATH 环境变量中，这样它在可以在命令行中执行（否则需要使用全路径名调用解释器）。<br> 对于 Windows 系统，需要手动将 C:\Python27 和 C:\Python37\Scripts（或自己设定的其他 Python 安装路径）添加到 PATH 变量中。首先打开控制面板，单击“系统”；或右击“我的电脑”，接着选择“属性”。在打开的窗口中选择“高级”标签，单击“环境变量”按钮。可以选择编辑单个用户的  PATH 项（上方的列表框），或者所有用户的  PATH（下方的列表框），接着在 Variable  Value 文本框中的末尾添加“;C:\Python37;C:\Python37\Scripts”<br> 在（任意一个平台上）设置好 PATH 以后，应该可以执行 Python 并获得一个交互式解释器，并查看 Django 的 django-admin.py 命令的使用方法。打开 UNIX shell 或 DOS 命令行，执行命令的名称。如果一切正常，就继续下面的内容。<br>下一步是到转到需要放置代码的文件夹或目录中。要在当前目录中创建项目，可以使用下面的命令（这里使用比较常见的项目名，如 mysite，读者也可以使用其他名称）。</p>
<pre><code>$ django-admin.py startproject mysite</code></pre><p>在 Django 中，基本的项目含有 4 个文件，分别是 init .py、manage.py、setting.py、urls.py（后面会添加到应用中）</p>
<pre><code>文   件   名    描述/用途
 __init__ .py    告诉Python 这是一个软件包
urls.py    全局    URL 配置(“URLconf”)
settings.py        项目相关的配置
manage.py        应用的命令行接口</code></pre><p>细心地童鞋会注意到，startproject 命令创建的每个文件都是纯Python 源码文件，没有.ini 文件、XML 数据，或其他配置语法。Django 尽力坚持“纯粹的 Python”这一信条。这样既可以在不向框架添加复杂东西的情况下拥有灵活性，同时也可以根据不同的情况从其他文件导入额外的配置，或动态计算数值，而不是硬编码。Django 中不适用其他内容，只有纯 Python。读者也可能注意到了 django-admin.py 也是 Python 脚本。其作为用户和项目之间的命令行接口。而 manage.py 同样可以用这种方式管理应用（这两条命令都有 Help 选项，可以从中了解到关于使用方面更多的信息）。</p>
<h1 id="运行开发服务器"><a href="#运行开发服务器" class="headerlink" title="运行开发服务器"></a>运行开发服务器</h1><p>到目前为止，还没有创建一个应用。尽管如此，已经可以使用一些 Django 功能了。其中一个最方便的是 Django 内置的 Web 服务器。该服务器运行在本地，专门用于开发阶段。注意，这里强烈建议不要用这个服务器部署公开页面，因为其仅用于开发用途。</p>
<p>为什么会存在这个开发服务器？主要有以下几点原因。<br>1．使用开发服务器，可以直接运行与测试项目和应用，无需完整的生产环境。<br>2．当改动 Python 源码文件并重新载入模块时，开发服务器会自动检测。这样既能节省时间，也能方便地使用系统，无须每次编辑代码后手动重启。<br>3．开发服务器知道如何为 Django 管理应用程序寻找和显示静态媒体文件，所以无须立即了解管理方面的内容（后面会介绍相关内容，现在只是不要把它与django-admin.py 脚本弄混了）。</p>
<p>通过项目中的 manage.py 工具，可以使用下面这个简单的命令运行开发服务器。</p>
<pre><code>(POSIX) $ python ./manage.py runserver
(PCs) C:\py\django\mysite&gt; python manage.py runserver</code></pre><p>如果使用POSIX 系统，并使用来授予脚本执行许可，就无须显式调用，如 ./manage.py runserver。在 DOS 命令行窗口中也同样可以做到，只需 Python 正确安装到 Windows 注册表中即可。<br>启动服务器后，应该能看到和下面例子相似的输出（Windows 使用不同的键组合来退出程序）。</p>
<pre><code>Validating models...
0 errors found.
Django version 1.2, using settings &#39;mysite.settings&#39; 
Development server is running at http://127.0.0.1:8000/ 
Quit the server with CONTROL-C.
在浏览器中打开链接（http://127.0.0.1:8000/或 http://localhost:8000/），就可以看到 Django的欢迎页面。
如果需要使用不同的端口运行服务器，可以在命令行中指定。例如，如果需要在端口 8080 运行它，
可以使用这条命令：
$ python ./manage.py runserver 8080。
读者可以在下面这个链接中找到所有的 runserver 选项：http://docs.djangoproject.com/en/dev/ref/django-admin/#django-a dmin-runserver。</code></pre><h1 id="创建应用（App）"><a href="#创建应用（App）" class="headerlink" title="创建应用（App）"></a>创建应用（App）</h1><p>既然拥有了一个项目，就可以在其中创建应用。为了创建一个博客应用，继续使用 manage.py：</p>
<pre><code>$ ./manage.py startapp blog</code></pre><p>如之前的项目一样，这里可以自行起名字，并不一定要使用 blog 这个名称。这一步与启动一个项目同样简单。现在在项目目录中有了一个 blog 目录。下面介绍了其中的内容，首先用POSIX 格式列出其中的内容</p>
<pre><code>$ ls -l blog 
total 24
-rw-r--r-- 1 wesley admin 0 Feb 21 08:08 init .py
-rw-r--r-- 1 wesley admin 175 Feb 21 08:08 models.py
-rw-r--r-- 1 wesley admin 514 Feb 21 08:08 tests.py
-rw-r--r-- 1 wesley admin 26 Feb 21 08:08 views.py

文  件   名    描     述 / 目 的
    init   .py     告诉Python 这是一个包
urls.py             应用的 URL 配置文件（“URLconf”），这个文件并不像项目的 URLconf 那样自动创建（所以上面的截图中没有）
models.py         数据模型
views.py         视图函数（即 MVC 中的控制器）
tests.py         单元测试</code></pre><p>与项目类似，应用也是一个 Python 包。但在这里，models.py 和 views.py 文件中目前还没有真正的代码，需要开发者在今后添加代码。单元测试文件 tests.py 也是如此。同样，即使可以使用项目的 URLconf 来分派访问，也不会自动创建本地应用的 URLconf。这需要手动创建它，接着使用项目 URLconf 里的 include()指令将请求分配给应用的URLconf。<br>了让Django 知道这个新的应用是项目的一部分，需要编辑settings.py（可以将其理解为配置文件）。使用编辑器打开这个文件，找到位于底部的 INSTALLED_APPS 这个元组。将应用名称（blog）添加到元组的末尾，如下所示。</p>
<pre><code>INSTALLED_APPS = (
   . . .
   &#39;blog&#39;,
)</code></pre><p>虽然结尾的逗号不是必需的，但如果今后向该元组中添加其他项，就无须添加逗号。Django 使用INSTALLED_APPS 来配置系统的不同部分，包括自动管理应用程序和测试框架。</p>
]]></content>
      <categories>
        <category>Web 框架</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>标准库-PYTHON</title>
    <url>/2020/03/20/%E6%A0%87%E5%87%86%E5%BA%93-PYTHON/</url>
    <content><![CDATA[<p>Python 标准库示例说明<br>Python拥有一个强大的标准库。Python语言的核心只包含数字、字符串、列表、字典、文件等常见类型和函数，而由Python标准库提供了系统管理、网络通信、文本处理、数据库接口、图形系统、XML处理等额外的功能。</p>
<a id="more"></a>

<h1 id="操作系统接口"><a href="#操作系统接口" class="headerlink" title="操作系统接口"></a>操作系统接口</h1><p>os模块提供了不少与操作系统相关联的函数。</p>
<pre><code>&gt;&gt;&gt; import os
&gt;&gt;&gt; os.getcwd()      # 返回当前的工作目录
&#39;C:\\Python34&#39;
&gt;&gt;&gt; os.chdir(&#39;/server/accesslogs&#39;)   # 修改当前的工作目录
&gt;&gt;&gt; os.system(&#39;mkdir today&#39;)   # 执行系统命令 mkdir 
0</code></pre><p>建议使用 “import os” 风格而非 “from os import *”。这样可以保证随操作系统不同而有所变化的 os.open() 不会覆盖内置函数 open()。</p>
<p>在使用 os 这样的大型模块时内置的 dir() 和 help() 函数非常有用:</p>
<pre><code>&gt;&gt;&gt; import os
&gt;&gt;&gt; dir(os)</code></pre><returns a list of all module functions>
>>> help(os)
<returns an extensive manual page created from the module's docstrings>
针对日常的文件和目录管理任务，:mod:shutil 模块提供了一个易于使用的高级接口:
```
>>> import shutil
>>> shutil.copyfile('data.db', 'archive.db')
>>> shutil.move('/build/executables', 'installdir')

<h1 id="文件通配符"><a href="#文件通配符" class="headerlink" title="文件通配符"></a>文件通配符</h1><p>glob模块提供了一个函数用于从目录通配符搜索中生成文件列表:</p>
<pre><code>&gt;&gt;&gt; import glob
&gt;&gt;&gt; glob.glob(&#39;*.py&#39;)
[&#39;primes.py&#39;, &#39;random.py&#39;, &#39;quote.py&#39;]
命令行参数
通用工具脚本经常调用命令行参数。这些命令行参数以链表形式存储于 sys 模块的 argv 变量。例如在命令行中执行 “python demo.py one two three” 后可以得到以下输出结果:

&gt;&gt;&gt; import sys
&gt;&gt;&gt; print(sys.argv)
[&#39;demo.py&#39;, &#39;one&#39;, &#39;two&#39;, &#39;three&#39;]
错误输出重定向和程序终止
sys 还有 stdin，stdout 和 stderr 属性，即使在 stdout 被重定向时，后者也可以用于显示警告和错误信息。

&gt;&gt;&gt; sys.stderr.write(&#39;Warning, log file not found starting a new one\n&#39;)
Warning, log file not found starting a new one
大多脚本的定向终止都使用 “sys.exit()”。</code></pre><h1 id="字符串正则匹配"><a href="#字符串正则匹配" class="headerlink" title="字符串正则匹配"></a>字符串正则匹配</h1><p>re模块为高级字符串处理提供了正则表达式工具。对于复杂的匹配和处理，正则表达式提供了简洁、优化的解决方案:</p>
<pre><code>&gt;&gt;&gt; import re
&gt;&gt;&gt; re.findall(r&#39;\bf[a-z]*&#39;, &#39;which foot or hand fell fastest&#39;)
[&#39;foot&#39;, &#39;fell&#39;, &#39;fastest&#39;]
&gt;&gt;&gt; re.sub(r&#39;(\b[a-z]+) \1&#39;, r&#39;\1&#39;, &#39;cat in the the hat&#39;)
&#39;cat in the hat&#39;
如果只需要简单的功能，应该首先考虑字符串方法，因为它们非常简单，易于阅读和调试:

&gt;&gt;&gt; &#39;tea for too&#39;.replace(&#39;too&#39;, &#39;two&#39;)
&#39;tea for two&#39;</code></pre><h1 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h1><p>math模块为浮点运算提供了对底层C函数库的访问:</p>
<pre><code>&gt;&gt;&gt; import math
&gt;&gt;&gt; math.cos(math.pi / 4)
0.70710678118654757
&gt;&gt;&gt; math.log(1024, 2)
10.0
random提供了生成随机数的工具。

&gt;&gt;&gt; import random
&gt;&gt;&gt; random.choice([&#39;apple&#39;, &#39;pear&#39;, &#39;banana&#39;])
&#39;apple&#39;
&gt;&gt;&gt; random.sample(range(100), 10)   # sampling without replacement
[30, 83, 16, 4, 8, 81, 41, 50, 18, 33]
&gt;&gt;&gt; random.random()    # random float
0.17970987693706186
&gt;&gt;&gt; random.randrange(6)    # random integer chosen from range(6)</code></pre><h1 id="访问-互联网"><a href="#访问-互联网" class="headerlink" title="访问 互联网"></a>访问 互联网</h1><p>有几个模块用于访问互联网以及处理网络通信协议。其中最简单的两个是用于处理从 urls 接收的数据的 urllib.request 以及用于发送电子邮件的 smtplib:</p>
<pre><code>&gt;&gt;&gt; from urllib.request import urlopen
&gt;&gt;&gt; for line in urlopen(&#39;http://tycho.usno.navy.mil/cgi-bin/timer.pl&#39;):
...     line = line.decode(&#39;utf-8&#39;)  # Decoding the binary data to text.
...     if &#39;EST&#39; in line or &#39;EDT&#39; in line:  # look for Eastern Time
...         print(line)
&lt;BR&gt;Nov. 25, 09:43:32 PM EST
&gt;&gt;&gt; import smtplib
&gt;&gt;&gt; server = smtplib.SMTP(&#39;localhost&#39;)
&gt;&gt;&gt; server.sendmail(&#39;soothsayer@example.org&#39;, &#39;jcaesar@example.org&#39;,
... &quot;&quot;&quot;To: jcaesar@example.org
... From: soothsayer@example.org
...
... Beware the Ides of March.
... &quot;&quot;&quot;)
&gt;&gt;&gt; server.quit()</code></pre><p>注意第二个例子需要本地有一个在运行的邮件服务器。</p>
<pre><code>#处理get请求，不传data，则为get请求
import urllib
from urllib.request import urlopen
from urllib.parse import urlencode
url=&#39;http://www.ai8py.com/login&#39;
data={&quot;username&quot;:&quot;admin&quot;,&quot;password&quot;:123456}
req_data=urlencode(data)#将字典类型的请求数据转变为url编码
res=urlopen(url+&#39;?&#39;+req_data)#通过urlopen方法访问拼接好的url
res=res.read().decode()#read()方法是读取返回数据内容，decode是转换返回数据的bytes格式为str
print(res)
#处理post请求,如果传了data，则为post请求
import urllib
from urllib.request import Request
from urllib.parse import urlencode
url=&#39;http://www.ai8py.com/login&#39;
data={&quot;username&quot;:&quot;admin&quot;,&quot;password&quot;:123456}
data=urlencode(data)#将字典类型的请求数据转变为url编码
data=data.encode(&#39;ascii&#39;)#将url编码类型的请求数据转变为bytes类型
req_data=Request(url,data)#将url和请求数据处理为一个Request对象，供urlopen调用
with urlopen(req_data) as res:
    res=res.read().decode()#read()方法是读取返回数据内容，decode是转换返回数据的bytes格式为str
print(res)</code></pre><h1 id="日期和时间"><a href="#日期和时间" class="headerlink" title="日期和时间"></a>日期和时间</h1><p>datetime模块为日期和时间处理同时提供了简单和复杂的方法。</p>
<p>支持日期和时间算法的同时，实现的重点放在更有效的处理和格式化输出。</p>
<p>该模块还支持时区处理:</p>
<pre><code>&gt;&gt;&gt; # dates are easily constructed and formatted
&gt;&gt;&gt; from datetime import date
&gt;&gt;&gt; now = date.today()
&gt;&gt;&gt; now
datetime.date(2003, 12, 2)
&gt;&gt;&gt; now.strftime(&quot;%m-%d-%y. %d %b %Y is a %A on the %d day of %B.&quot;)
&#39;12-02-03. 02 Dec 2003 is a Tuesday on the 02 day of December.&#39;
&gt;&gt;&gt; # dates support calendar arithmetic
&gt;&gt;&gt; birthday = date(1964, 7, 31)
&gt;&gt;&gt; age = now - birthday
&gt;&gt;&gt; age.days
14368</code></pre><p>常用时间处理方法</p>
<p>今天 today = datetime.date.today()<br>昨天 yesterday = today - datetime.timedelta(days=1)<br>上个月 last_month = today.month - 1 if today.month - 1 else 12<br>当前时间戳 time_stamp = time.time()<br>时间戳转datetime datetime.datetime.fromtimestamp(time_stamp)<br>datetime转时间戳 int(time.mktime(today.timetuple()))<br>datetime转字符串 today_str = today.strftime(“%Y-%m-%d”)<br>字符串转datetime today = datetime.datetime.strptime(today_str, “%Y-%m-%d”)<br>补时差 today + datetime.timedelta(hours=8)</p>
<h1 id="数据压缩"><a href="#数据压缩" class="headerlink" title="数据压缩"></a>数据压缩</h1><p>以下模块直接支持通用的数据打包和压缩格式：zlib，gzip，bz2，zipfile，以及 tarfile。</p>
<pre><code>&gt;&gt;&gt; import zlib
&gt;&gt;&gt; s = b&#39;witch which has which witches wrist watch&#39;
&gt;&gt;&gt; len(s)
41
&gt;&gt;&gt; t = zlib.compress(s)
&gt;&gt;&gt; len(t)
37
&gt;&gt;&gt; zlib.decompress(t)
b&#39;witch which has which witches wrist watch&#39;
&gt;&gt;&gt; zlib.crc32(s)
226805979</code></pre><h1 id="性能度量"><a href="#性能度量" class="headerlink" title="性能度量"></a>性能度量</h1><p>有些用户对了解解决同一问题的不同方法之间的性能差异很感兴趣。Python 提供了一个度量工具，为这些问题提供了直接答案。</p>
<p>例如，使用元组封装和拆封来交换元素看起来要比使用传统的方法要诱人的多,timeit 证明了现代的方法更快一些。</p>
<pre><code>&gt;&gt;&gt; from timeit import Timer
&gt;&gt;&gt; Timer(&#39;t=a; a=b; b=t&#39;, &#39;a=1; b=2&#39;).timeit()
0.57535828626024577
&gt;&gt;&gt; Timer(&#39;a,b = b,a&#39;, &#39;a=1; b=2&#39;).timeit()
0.54962537085770791
相对于 timeit 的细粒度，:mod:profile 和 pstats 模块提供了针对更大代码块的时间度量工具。</code></pre><h1 id="测试模块"><a href="#测试模块" class="headerlink" title="测试模块"></a>测试模块</h1><p>开发高质量软件的方法之一是为每一个函数开发测试代码，并且在开发过程中经常进行测试</p>
<p>doctest模块提供了一个工具，扫描模块并根据程序中内嵌的文档字符串执行测试。</p>
<p>测试构造如同简单的将它的输出结果剪切并粘贴到文档字符串中。</p>
<p>通过用户提供的例子，它强化了文档，允许 doctest 模块确认代码的结果是否与文档一致:</p>
<pre><code>def average(values):
    &quot;&quot;&quot;Computes the arithmetic mean of a list of numbers.
    &gt;&gt;&gt; print(average([20, 30, 70]))
    40.0
    &quot;&quot;&quot;
    return sum(values) / len(values)
import doctest
doctest.testmod()   # 自动验证嵌入测试
unittest模块不像 doctest模块那么容易使用，不过它可以在一个独立的文件里提供一个更全面的测试集:

import unittest
class TestStatisticalFunctions(unittest.TestCase):
    def test_average(self):
        self.assertEqual(average([20, 30, 70]), 40.0)
        self.assertEqual(round(average([1, 5, 7]), 1), 4.3)
        self.assertRaises(ZeroDivisionError, average, [])
        self.assertRaises(TypeError, average, 20, 30, 70)
unittest.main() # Calling from the command line invokes all tests</code></pre></returns></returns>]]></content>
      <categories>
        <category>基础常识</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象-PYTHON</title>
    <url>/2020/03/20/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-PYTHON/</url>
    <content><![CDATA[<p>Python 面向对象class<br>类就是一个模板，模板里可以包含多个函数，函数里实现一些功能<br>对象则是根据模板创建的实例，通过实例对象可以执行类中的函数</p>
<a id="more"></a>

<p>Python从设计之初就已经是一门面向对象的语言，正因为如此，在Python中创建一个类和对象是很容易的。</p>
<p>如果你以前没有接触过面向对象的编程语言，那你可能需要先了解一些面向对象语言的一些基本特征，在头脑里头形成一个基本的面向对象的概念，这样有助于你更容易的学习Python的面向对象编程。</p>
<p>接下来我们先来简单的了解下面向对象的一些基本特征。</p>
<h1 id="面向对象技术简介"><a href="#面向对象技术简介" class="headerlink" title="面向对象技术简介"></a>面向对象技术简介</h1><p>类(Class): 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。<br>方法：类中定义的函数。<br>类变量：类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。<br>数据成员：类变量或者实例变量用于处理类及其实例对象的相关的数据。<br>方法重写：如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。<br>局部变量：定义在方法中的变量，只作用于当前实例的类。<br>实例变量：在类的声明中，属性是用变量来表示的。这种变量就称为实例变量，是在类声明的内部但是在类的其他成员方法之外声明的。<br>继承：即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个Dog类型的对象派生自Animal类，这是模拟”是一个（is-a）”关系（例图，Dog是一个Animal）。<br>实例化：创建一个类的实例，类的具体对象。<br>对象：通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。<br>和其它编程语言相比，Python 在尽可能不增加新的语法和语义的情况下加入了类机制。</p>
<p>Python中的类提供了面向对象编程的所有基本功能：类的继承机制允许多个基类，派生类可以覆盖基类中的任何方法，方法中可以调用基类中的同名方法。</p>
<p>对象可以包含任意数量和类型的数据。</p>
<h1 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h1><p>语法格式如下：</p>
<pre><code>class ClassName:
    &lt;statement-1&gt;
    .
    .
    .
    &lt;statement-N&gt;
类实例化后，可以使用其属性，实际上，创建一个类之后，可以通过类名访问其属性。

类对象
类对象支持两种操作：属性引用和实例化。
属性引用使用和 Python 中所有的属性引用一样的标准语法：obj.name。
类对象创建后，类命名空间中所有的命名都是有效属性名。所以如果类定义是这样:

#!/usr/bin/python3

class MyClass:
    &quot;&quot;&quot;一个简单的类实例&quot;&quot;&quot;
    i = 12345
    def f(self):
        return &#39;hello world&#39;

# 实例化类
x = MyClass()

# 访问类的属性和方法
print(&quot;MyClass 类的属性 i 为：&quot;, x.i)
print(&quot;MyClass 类的方法 f 输出为：&quot;, x.f())
以上创建了一个新的类实例并将该对象赋给局部变量 x，x 为空的对象。

执行以上程序输出结果为：

MyClass 类的属性 i 为： 12345
MyClass 类的方法 f 输出为： hello world</code></pre><p>类有一个名为 <strong>init</strong>() 的特殊方法（构造方法），该方法在类实例化时会自动调用，像下面这样：</p>
<pre><code>def __init__(self):
    self.data = []
类定义了 __init__() 方法，类的实例化操作会自动调用 __init__() 方法。如下实例化类 MyClass，对应的 __init__() 方法就会被调用:

x = MyClass()
当然， __init__() 方法可以有参数，参数通过 __init__() 传递到类的实例化操作上。例如:

#!/usr/bin/python3

class Complex:
    def __init__(self, realpart, imagpart):
        self.r = realpart
        self.i = imagpart
x = Complex(3.0, -4.5)
print(x.r, x.i)   # 输出结果：3.0 -4.5</code></pre><h1 id="self代表类的实例，而非类"><a href="#self代表类的实例，而非类" class="headerlink" title="self代表类的实例，而非类"></a>self代表类的实例，而非类</h1><p>类的方法与普通的函数只有一个特别的区别——它们必须有一个额外的第一个参数名称, 按照惯例它的名称是 self。</p>
<pre><code>class Test:
    def prt(self):
        print(self)
        print(self.__class__)

t = Test()
t.prt()
以上实例执行结果为：

&lt;__main__.Test instance at 0x100771878&gt;
__main__.Test
从执行结果可以很明显的看出，self 代表的是类的实例，代表当前对象的地址，而 self.class 则指向类。

self 不是 python 关键字，我们把他换成 ai8py也是可以正常执行的:

class Test:
    def prt(ai8py):
        print(ai8py)
        print(ai8py.__class__)

t = Test()
t.prt()
以上实例执行结果为：

&lt;__main__.Test instance at 0x100771878&gt;
__main__.Test</code></pre><h1 id="类的方法"><a href="#类的方法" class="headerlink" title="类的方法"></a>类的方法</h1><p>在类的内部，使用 def 关键字来定义一个方法，与一般函数定义不同，类方法必须包含参数 self, 且为第一个参数，self 代表的是类的实例。</p>
<pre><code>#!/usr/bin/python3

#类定义
class people:
    #定义基本属性
    name = &#39;&#39;
    age = 0
    #定义私有属性,私有属性在类外部无法直接进行访问
    __weight = 0
    #定义构造方法
    def __init__(self,n,a,w):
        self.name = n
        self.age = a
        self.__weight = w
    def speak(self):
        print(&quot;%s 说: 我 %d 岁。&quot; %(self.name,self.age))

# 实例化类
p = people(&#39;ai8py&#39;,10,30)
p.speak()
执行以上程序输出结果为：

ai8py 说: 我 10 岁。</code></pre><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>Python 同样支持类的继承，如果一种语言不支持继承，类就没有什么意义。派生类的定义如下所示:</p>
<pre><code>class DerivedClassName(BaseClassName1):
    &lt;statement-1&gt;
    .
    .
    .
    &lt;statement-N&gt;
需要注意圆括号中基类的顺序，若是基类中有相同的方法名，而在子类使用时未指定，python从左至右搜索 即方法在子类中未找到时，从左到右查找基类中是否包含方法。

BaseClassName（示例中的基类名）必须与派生类定义在一个作用域内。除了类，还可以用表达式，基类定义在另一个模块中时这一点非常有用:

class DerivedClassName(modname.BaseClassName):
#!/usr/bin/python3

#类定义
class people:
    #定义基本属性
    name = &#39;&#39;
    age = 0
    #定义私有属性,私有属性在类外部无法直接进行访问
    __weight = 0
    #定义构造方法
    def __init__(self,n,a,w):
        self.name = n
        self.age = a
        self.__weight = w
    def speak(self):
        print(&quot;%s 说: 我 %d 岁。&quot; %(self.name,self.age))

#单继承示例
class student(people):
    grade = &#39;&#39;
    def __init__(self,n,a,w,g):
        #调用父类的构函
        people.__init__(self,n,a,w)
        self.grade = g
    #覆写父类的方法
    def speak(self):
        print(&quot;%s 说: 我 %d 岁了，我在读 %d 年级&quot;%(self.name,self.age,self.grade))



s = student(&#39;ken&#39;,10,60,3)
s.speak()
执行以上程序输出结果为：

ken 说: 我 10 岁了，我在读 3 年级</code></pre><h1 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h1><p>Python同样有限的支持多继承形式。多继承的类定义形如下例:</p>
<pre><code>class DerivedClassName(Base1, Base2, Base3):
    &lt;statement-1&gt;
    .
    .
    .
    &lt;statement-N&gt;
需要注意圆括号中父类的顺序，若是父类中有相同的方法名，而在子类使用时未指定，python从左至右搜索 即方法在子类中未找到时，从左到右查找父类中是否包含方法。

#!/usr/bin/python3

#类定义
class people:
    #定义基本属性
    name = &#39;&#39;
    age = 0
    #定义私有属性,私有属性在类外部无法直接进行访问
    __weight = 0
    #定义构造方法
    def __init__(self,n,a,w):
        self.name = n
        self.age = a
        self.__weight = w
    def speak(self):
        print(&quot;%s 说: 我 %d 岁。&quot; %(self.name,self.age))

#单继承示例
class student(people):
    grade = &#39;&#39;
    def __init__(self,n,a,w,g):
        #调用父类的构函
        people.__init__(self,n,a,w)
        self.grade = g
    #覆写父类的方法
    def speak(self):
        print(&quot;%s 说: 我 %d 岁了，我在读 %d 年级&quot;%(self.name,self.age,self.grade))

#另一个类，多重继承之前的准备
class speaker():
    topic = &#39;&#39;
    name = &#39;&#39;
    def __init__(self,n,t):
        self.name = n
        self.topic = t
    def speak(self):
        print(&quot;我叫 %s，我是一个演说家，我演讲的主题是 %s&quot;%(self.name,self.topic))

#多重继承
class sample(speaker,student):
    a =&#39;&#39;
    def __init__(self,n,a,w,g,t):
        student.__init__(self,n,a,w,g)
        speaker.__init__(self,n,t)

test = sample(&quot;Tim&quot;,25,80,4,&quot;Python&quot;)
test.speak()   #方法名同，默认调用的是在括号中排前地父类的方法
执行以上程序输出结果为：

我叫 Tim，我是一个演说家，我演讲的主题是 Python</code></pre><h1 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h1><p>如果你的父类方法的功能不能满足你的需求，你可以在子类重写你父类的方法，实例如下：</p>
<pre><code>#!/usr/bin/python3

class Parent:        # 定义父类
   def myMethod(self):
      print (&#39;调用父类方法&#39;)

class Child(Parent): # 定义子类
   def myMethod(self):
      print (&#39;调用子类方法&#39;)

c = Child()          # 子类实例
c.myMethod()         # 子类调用重写方法
super(Child,c).myMethod() #用子类对象调用父类已被覆盖的方法
super() 函数是用于调用父类(超类)的一个方法。

执行以上程序输出结果为：

调用子类方法
调用父类方法</code></pre><h1 id="类属性与方法"><a href="#类属性与方法" class="headerlink" title="类属性与方法"></a>类属性与方法</h1><p>类的私有属性<br><strong>private_attrs：两个下划线开头，声明该属性为私有，不能在类的外部被使用或直接访问。在类内部的方法中使用时 self.</strong>private_attrs。</p>
<p>类的方法<br>在类的内部，使用 def 关键字来定义一个方法，与一般函数定义不同，类方法必须包含参数 self，且为第一个参数，self 代表的是类的实例。</p>
<p>self 的名字并不是规定死的，也可以使用 this，但是最好还是按照约定是用 self。</p>
<p>类的私有方法<br><strong>private_method：两个下划线开头，声明该方法为私有方法，只能在类的内部调用 ，不能在类的外部调用。self.</strong>private_methods。</p>
<p>类的私有属性实例如下：</p>
<pre><code>#!/usr/bin/python3

class JustCounter:
    __secretCount = 0  # 私有变量
    publicCount = 0    # 公开变量

    def count(self):
        self.__secretCount += 1
        self.publicCount += 1
        print (self.__secretCount)

counter = JustCounter()
counter.count()
counter.count()
print (counter.publicCount)
print (counter.__secretCount)  # 报错，实例不能访问私有变量
执行以上程序输出结果为：

1
2
2
Traceback (most recent call last):
  File &quot;test.py&quot;, line 16, in &lt;module&gt;
    print (counter.__secretCount)  # 报错，实例不能访问私有变量
AttributeError: &#39;JustCounter&#39; object has no attribute &#39;__secretCount&#39;
类的私有方法实例如下：

#!/usr/bin/python3

class Site:
    def __init__(self, name, url):
        self.name = name       # public
        self.__url = url   # private

    def who(self):
        print(&#39;name  : &#39;, self.name)
        print(&#39;url : &#39;, self.__url)

    def __foo(self):          # 私有方法
        print(&#39;这是私有方法&#39;)

    def foo(self):            # 公共方法
        print(&#39;这是公共方法&#39;)
        self.__foo()

x = Site(&#39;蟒蛇教程&#39;, &#39;www.ai8py.com&#39;)
x.who()        # 正常输出
x.foo()        # 正常输出
x.__foo()      # 报错
以上实例执行结果：

Traceback (most recent call last):
  File &quot;D:\code\eclipse-workspace\ai8py\src\test1.py&quot;, line 22, in &lt;module&gt;
name  :  蟒蛇教程
url :  www.ai8py.com
这是公共方法
这是私有方法
    x.__foo()      # 报错
AttributeError: &#39;Site&#39; object has no attribute &#39;__foo&#39;</code></pre><h1 id="类的专有方法："><a href="#类的专有方法：" class="headerlink" title="类的专有方法："></a>类的专有方法：</h1><p><strong>init</strong> : 构造函数，在生成对象时调用<br><strong>del</strong> : 析构函数，释放对象时使用<br><strong>repr</strong> : 打印，转换<br><strong>setitem</strong> : 按照索引赋值<br><strong>getitem</strong>: 按照索引获取值<br><strong>len</strong>: 获得长度<br><strong>cmp</strong>: 比较运算<br><strong>call</strong>: 函数调用<br><strong>add</strong>: 加运算<br><strong>sub</strong>: 减运算<br><strong>mul</strong>: 乘运算<br><strong>truediv</strong>: 除运算<br><strong>mod</strong>: 求余运算<br><strong>pow</strong>: 乘方</p>
<h1 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h1><p>Python同样支持运算符重载，我们可以对类的专有方法进行重载，实例如下：</p>
<pre><code>#!/usr/bin/python3

class Vector:
   def __init__(self, a, b):
      self.a = a
      self.b = b

   def __str__(self):
      return &#39;Vector (%d, %d)&#39; % (self.a, self.b)

   def __add__(self,other):
      return Vector(self.a + other.a, self.b + other.b)

v1 = Vector(2,10)
v2 = Vector(5,-2)
print (v1 + v2)
以上代码执行结果如下所示:

Vector(7,8)</code></pre>]]></content>
      <categories>
        <category>基础进阶</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>迭代器生成器-PYTHON</title>
    <url>/2020/03/20/%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%94%9F%E6%88%90%E5%99%A8-PYTHON/</url>
    <content><![CDATA[<p>Python 迭代器与生成器<br>可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator。<br>在Python中，这种一边循环一边计算的机制，称为生成器：generator</p>
<a id="more"></a>
<h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><p>迭代是Python最强大的功能之一，是访问集合元素的一种方式。<br>迭代器是一个可以记住遍历的位置的对象。<br>迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。<br>迭代器只能往前不会后退。<br>迭代器有两个基本的方法：iter() 和 next()。<br>字符串，列表或元组对象都可用于创建迭代器：</p>
<pre><code>&gt;&gt;&gt;list=[1,2,3,4]
&gt;&gt;&gt; it = iter(list)    # 创建迭代器对象
&gt;&gt;&gt; print (next(it))   # 输出迭代器的下一个元素
1
&gt;&gt;&gt; print (next(it))
2
&gt;&gt;&gt;</code></pre><h1 id="迭代器对象可以使用常规for语句进行遍历："><a href="#迭代器对象可以使用常规for语句进行遍历：" class="headerlink" title="迭代器对象可以使用常规for语句进行遍历："></a>迭代器对象可以使用常规for语句进行遍历：</h1><pre><code>#!/usr/bin/python3

list=[1,2,3,4]
it = iter(list)    # 创建迭代器对象
for x in it:
    print (x, end=&quot; &quot;)
执行以上程序，输出结果如下：

1 2 3 4</code></pre><p>也可以使用 next() 函数：</p>
<pre><code>#!/usr/bin/python3

import sys         # 引入 sys 模块

list=[1,2,3,4]
it = iter(list)    # 创建迭代器对象

while True:
    try:
        print (next(it))
    except StopIteration:
        sys.exit()
执行以上程序，输出结果如下：

1
2
3
4</code></pre><h1 id="创建一个迭代器"><a href="#创建一个迭代器" class="headerlink" title="创建一个迭代器"></a>创建一个迭代器</h1><p>把一个类作为一个迭代器使用需要在类中实现两个方法 <strong>iter</strong>() 与 <strong>next</strong>() 。<br>如果你已经了解的面向对象编程，就知道类都有一个构造函数，Python 的构造函数为 <strong>init</strong>(), 它会在对象初始化的时候执行。<br>更多内容查阅：Python 面向对象<br><strong>iter</strong>() 方法返回一个特殊的迭代器对象， 这个迭代器对象实现了 <strong>next</strong>() 方法并通过 StopIteration 异常标识迭代的完成。<br><strong>next</strong>() 方法（Python 2 里是 next()）会返回下一个迭代器对象。<br>创建一个返回数字的迭代器，初始值为 1，逐步递增 1：</p>
<pre><code>class MyNumbers:
  def __iter__(self):
    self.a = 1
    return self

  def __next__(self):
    x = self.a
    self.a += 1
    return x

myclass = MyNumbers()
myiter = iter(myclass)

print(next(myiter))
print(next(myiter))
print(next(myiter))
print(next(myiter))
print(next(myiter))
执行输出结果为：

1
2
3
4
5</code></pre><h1 id="StopIteration"><a href="#StopIteration" class="headerlink" title="StopIteration"></a>StopIteration</h1><p>StopIteration 异常用于标识迭代的完成，防止出现无限循环的情况，在 <strong>next</strong>() 方法中我们可以设置在完成指定循环次数后触发 StopIteration 异常来结束迭代。<br>在 20 次迭代后停止执行：</p>
<pre><code>class MyNumbers:
  def __iter__(self):
    self.a = 1
    return self

  def __next__(self):
    if self.a &lt;= 20:
      x = self.a
      self.a += 1
      return x
    else:
      raise StopIteration

myclass = MyNumbers()
myiter = iter(myclass)

for x in myiter:
  print(x)
执行输出结果为：

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20</code></pre><h1 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h1><p>在 Python 中，使用了 yield 的函数被称为生成器（generator）。<br>跟普通函数不同的是，生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器。<br>在调用生成器运行的过程中，每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回 yield 的值, 并在下一次执行 next() 方法时从当前位置继续运行。<br>调用一个生成器函数，返回的是一个迭代器对象。<br>以下实例使用 yield 实现斐波那契数列：</p>
<pre><code>#!/usr/bin/python3

import sys

def fibonacci(n): # 生成器函数 - 斐波那契
    a, b, counter = 0, 1, 0
    while True:
        if (counter &gt; n): 
            return
        yield a
        a, b = b, a + b
        counter += 1
f = fibonacci(10) # f 是一个迭代器，由生成器返回生成

while True:
    try:
        print (next(f), end=&quot; &quot;)
    except StopIteration:
        sys.exit()
执行以上程序，输出结果如下：

0 1 1 2 3 5 8 13 21 34 55</code></pre>]]></content>
      <categories>
        <category>基础进阶</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程-PYTHON</title>
    <url>/2020/03/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B-PYTHON/</url>
    <content><![CDATA[<p>Python 多线程Threading<br>任何进程默认就会启动一个线程，我们把该线程称为主线程，主线程又可以启动新的线程，Python的threading模块有个current_thread()函数，它永远返回当前线程的实例。主线程实例的名字叫MainThread，子线程的名字在创建时指定，我们用LoopThread命名子线程。</p>
<a id="more"></a>
<p>多线程类似于同时执行多个不同程序，多线程运行有如下优点：</p>
<p>使用线程可以把占据长时间的程序中的任务放到后台去处理。<br>用户界面可以更加吸引人，比如用户点击了一个按钮去触发某些事件的处理，可以弹出一个进度条来显示处理的进度<br>程序的运行速度可能加快<br>在一些等待的任务实现上如用户输入、文件读写和网络收发数据等，线程就比较有用了。在这种情况下我们可以释放一些珍贵的资源如内存占用等等。<br>线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</p>
<p>每个线程都有他自己的一组CPU寄存器，称为线程的上下文，该上下文反映了线程上次运行该线程的CPU寄存器的状态。</p>
<p>指令指针和堆栈指针寄存器是线程上下文中两个最重要的寄存器，线程总是在进程得到上下文中运行的，这些地址都用于标志拥有线程的进程地址空间中的内存。</p>
<p>线程可以被抢占（中断）。<br>在其他线程正在运行时，线程可以暂时搁置（也称为睡眠） — 这就是线程的退让。<br>线程可以分为:</p>
<p>内核线程：由操作系统内核创建和撤销。<br>用户线程：不需要内核支持而在用户程序中实现的线程。<br>Python3 线程中常用的两个模块为：</p>
<p>_thread<br>threading(推荐使用)<br>thread 模块已被废弃。用户可以使用 threading 模块代替。所以，在 Python3 中不能再使用”thread” 模块。为了兼容性，Python3 将 thread 重命名为 “_thread”。</p>
<h1 id="开始学习Python线程"><a href="#开始学习Python线程" class="headerlink" title="开始学习Python线程"></a>开始学习Python线程</h1><p>Python中使用线程有两种方式：函数或者用类来包装线程对象。</p>
<p>函数式：调用 _thread 模块中的start_new_thread()函数来产生新线程。语法如下:</p>
<p>_thread.start_new_thread ( function, args[, kwargs] )</p>
<h1 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明:"></a>参数说明:</h1><p>function – 线程函数。<br>args – 传递给线程函数的参数,他必须是个tuple类型。<br>kwargs – 可选参数。<br>实例：</p>
<pre><code>#!/usr/bin/python3
import _thread
import time
# 为线程定义一个函数
def print_time( threadName, delay):
   count = 0
   while count &lt; 5:
      time.sleep(delay)
      count += 1
      print (&quot;%s: %s&quot; % ( threadName, time.ctime(time.time()) ))
# 创建两个线程 
try:
   _thread.start_new_thread( print_time, (&quot;Thread-1&quot;, 2, ) )
   _thread.start_new_thread( print_time, (&quot;Thread-2&quot;, 4, ) )
except:
   print (&quot;Error: 无法启动线程&quot;)
while 1:
   pass

执行以上程序输出结果如下：

Thread-1: Wed Apr  6 11:36:31 2016
Thread-1: Wed Apr  6 11:36:33 2016
Thread-2: Wed Apr  6 11:36:33 2016
Thread-1: Wed Apr  6 11:36:35 2016
Thread-1: Wed Apr  6 11:36:37 2016
Thread-2: Wed Apr  6 11:36:37 2016
Thread-1: Wed Apr  6 11:36:39 2016
Thread-2: Wed Apr  6 11:36:41 2016
Thread-2: Wed Apr  6 11:36:45 2016
Thread-2: Wed Apr  6 11:36:49 2016
执行以上程后可以按下 ctrl-c to 退出。</code></pre><h1 id="线程模块"><a href="#线程模块" class="headerlink" title="线程模块"></a>线程模块</h1><p>Python3 通过两个标准库 _thread 和 threading 提供对线程的支持。</p>
<p>_thread 提供了低级别的、原始的线程以及一个简单的锁，它相比于 threading 模块的功能还是比较有限的。</p>
<p>threading 模块除了包含 _thread 模块中的所有方法外，还提供的其他方法：</p>
<p>threading.currentThread(): 返回当前的线程变量。<br>threading.enumerate(): 返回一个包含正在运行的线程的list。正在运行指线程启动后、结束前，不包括启动前和终止后的线程。<br>threading.activeCount(): 返回正在运行的线程数量，与len(threading.enumerate())有相同的结果。<br>除了使用方法外，线程模块同样提供了Thread类来处理线程，Thread类提供了以下方法:</p>
<p>run(): 用以表示线程活动的方法。<br>start():启动线程活动。<br>join([time]): 等待至线程中止。这阻塞调用线程直至线程的join() 方法被调用中止-正常退出或者抛出未处理的异常-或者是可选的超时发生。<br>isAlive(): 返回线程是否活动的。<br>getName(): 返回线程名。<br>setName(): 设置线程名。</p>
<h1 id="使用-threading-模块创建线程"><a href="#使用-threading-模块创建线程" class="headerlink" title="使用 threading 模块创建线程"></a>使用 threading 模块创建线程</h1><p>我们可以通过直接从 threading.Thread 继承创建一个新的子类，并实例化后调用 start() 方法启动新线程，即它调用了线程的 run() 方法：</p>
<pre><code>#!/usr/bin/python3
import threading
import time
exitFlag = 0
class myThread (threading.Thread):
    def __init__(self, threadID, name, counter):
        threading.Thread.__init__(self)
        self.threadID = threadID
        self.name = name
        self.counter = counter
    def run(self):
        print (&quot;开始线程：&quot; + self.name)
        print_time(self.name, self.counter, 5)
        print (&quot;退出线程：&quot; + self.name)
def print_time(threadName, delay, counter):
    while counter:
        if exitFlag:
            threadName.exit()
        time.sleep(delay)
        print (&quot;%s: %s&quot; % (threadName, time.ctime(time.time())))
        counter -= 1
# 创建新线程
thread1 = myThread(1, &quot;Thread-1&quot;, 1)
thread2 = myThread(2, &quot;Thread-2&quot;, 2)
# 开启新线程
thread1.start()
thread2.start()
thread1.join()
thread2.join()
print (&quot;退出主线程&quot;)
以上程序执行结果如下；

开始线程：Thread-1
开始线程：Thread-2
Thread-1: Wed Apr  6 11:46:46 2016
Thread-1: Wed Apr  6 11:46:47 2016
Thread-2: Wed Apr  6 11:46:47 2016
Thread-1: Wed Apr  6 11:46:48 2016
Thread-1: Wed Apr  6 11:46:49 2016
Thread-2: Wed Apr  6 11:46:49 2016
Thread-1: Wed Apr  6 11:46:50 2016
退出线程：Thread-1
Thread-2: Wed Apr  6 11:46:51 2016
Thread-2: Wed Apr  6 11:46:53 2016
Thread-2: Wed Apr  6 11:46:55 2016
退出线程：Thread-2
退出主线程</code></pre><h1 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h1><p>如果多个线程共同对某个数据修改，则可能出现不可预料的结果，为了保证数据的正确性，需要对多个线程进行同步。</p>
<p>使用 Thread 对象的 Lock 和 Rlock 可以实现简单的线程同步，这两个对象都有 acquire 方法和 release 方法，对于那些需要每次只允许一个线程操作的数据，可以将其操作放到 acquire 和 release 方法之间。如下：</p>
<p>多线程的优势在于可以同时运行多个任务（至少感觉起来是这样）。但是当线程需要共享数据时，可能存在数据不同步的问题。</p>
<p>考虑这样一种情况：一个列表里所有元素都是0，线程”set”从后向前把所有元素改成1，而线程”print”负责从前往后读取列表并打印。</p>
<p>那么，可能线程”set”开始改的时候，线程”print”便来打印列表了，输出就成了一半0一半1，这就是数据的不同步。为了避免这种情况，引入了锁的概念。</p>
<p>锁有两种状态——锁定和未锁定。每当一个线程比如”set”要访问共享数据时，必须先获得锁定；如果已经有别的线程比如”print”获得锁定了，那么就让线程”set”暂停，也就是同步阻塞；等到线程”print”访问完毕，释放锁以后，再让线程”set”继续。</p>
<p>经过这样的处理，打印列表时要么全部输出0，要么全部输出1，不会再出现一半0一半1的尴尬场面。</p>
<p>实例：</p>
<pre><code>#!/usr/bin/python3
import threading
import time
class myThread (threading.Thread):
    def __init__(self, threadID, name, counter):
        threading.Thread.__init__(self)
        self.threadID = threadID
        self.name = name
        self.counter = counter
    def run(self):
        print (&quot;开启线程： &quot; + self.name)
        # 获取锁，用于线程同步
        threadLock.acquire()
        print_time(self.name, self.counter, 3)
        # 释放锁，开启下一个线程
        threadLock.release()
def print_time(threadName, delay, counter):
    while counter:
        time.sleep(delay)
        print (&quot;%s: %s&quot; % (threadName, time.ctime(time.time())))
        counter -= 1
threadLock = threading.Lock()
threads = []
# 创建新线程
thread1 = myThread(1, &quot;Thread-1&quot;, 1)
thread2 = myThread(2, &quot;Thread-2&quot;, 2)
# 开启新线程
thread1.start()
thread2.start()
# 添加线程到线程列表
threads.append(thread1)
threads.append(thread2)
# 等待所有线程完成
for t in threads:
    t.join()
print (&quot;退出主线程&quot;)
执行以上程序，输出结果为：

开启线程： Thread-1
开启线程： Thread-2
Thread-1: Wed Apr  6 11:52:57 2016
Thread-1: Wed Apr  6 11:52:58 2016
Thread-1: Wed Apr  6 11:52:59 2016
Thread-2: Wed Apr  6 11:53:01 2016
Thread-2: Wed Apr  6 11:53:03 2016
Thread-2: Wed Apr  6 11:53:05 2016
退出主线程</code></pre><h1 id="线程优先级队列（-Queue）"><a href="#线程优先级队列（-Queue）" class="headerlink" title="线程优先级队列（ Queue）"></a>线程优先级队列（ Queue）</h1><p>Python 的 Queue 模块中提供了同步的、线程安全的队列类，包括FIFO（先入先出)队列Queue，LIFO（后入先出）队列LifoQueue，和优先级队列 PriorityQueue。</p>
<p>这些队列都实现了锁原语，能够在多线程中直接使用，可以使用队列来实现线程间的同步。</p>
<p>Queue 模块中的常用方法:</p>
<pre><code>Queue.qsize() 返回队列的大小
Queue.empty() 如果队列为空，返回True,反之False
Queue.full() 如果队列满了，返回True,反之False
Queue.full 与 maxsize 大小对应
Queue.get([block[, timeout]])获取队列，timeout等待时间
Queue.get_nowait() 相当Queue.get(False)
Queue.put(item) 写入队列，timeout等待时间
Queue.put_nowait(item) 相当Queue.put(item, False)
Queue.task_done() 在完成一项工作之后，Queue.task_done()函数向任务已经完成的队列发送一个信号
Queue.join() 实际上意味着等到队列为空，再执行别的操作</code></pre><p>实例:</p>
<pre><code>#!/usr/bin/python3
import queue
import threading
import time
exitFlag = 0
class myThread (threading.Thread):
    def __init__(self, threadID, name, q):
        threading.Thread.__init__(self)
        self.threadID = threadID
        self.name = name
        self.q = q
    def run(self):
        print (&quot;开启线程：&quot; + self.name)
        process_data(self.name, self.q)
        print (&quot;退出线程：&quot; + self.name)
def process_data(threadName, q):
    while not exitFlag:
        queueLock.acquire()
        if not workQueue.empty():
            data = q.get()
            queueLock.release()
            print (&quot;%s processing %s&quot; % (threadName, data))
        else:
            queueLock.release()
        time.sleep(1)
threadList = [&quot;Thread-1&quot;, &quot;Thread-2&quot;, &quot;Thread-3&quot;]
nameList = [&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;, &quot;Four&quot;, &quot;Five&quot;]
queueLock = threading.Lock()
workQueue = queue.Queue(10)
threads = []
threadID = 1
# 创建新线程
for tName in threadList:
    thread = myThread(threadID, tName, workQueue)
    thread.start()
    threads.append(thread)
    threadID += 1
# 填充队列
queueLock.acquire()
for word in nameList:
    workQueue.put(word)
queueLock.release()
# 等待队列清空
while not workQueue.empty():
    pass
# 通知线程是时候退出
exitFlag = 1
# 等待所有线程完成
for t in threads:
    t.join()
print (&quot;退出主线程&quot;)
以上程序执行结果：

开启线程：Thread-1
开启线程：Thread-2
开启线程：Thread-3
Thread-3 processing One
Thread-1 processing Two
Thread-2 processing Three
Thread-3 processing Four
Thread-1 processing Five
退出线程：Thread-3
退出线程：Thread-2
退出线程：Thread-1
退出主线程</code></pre>]]></content>
      <categories>
        <category>基础进阶</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>错误和异常-PYTHON</title>
    <url>/2020/03/19/%E9%94%99%E8%AF%AF%E5%92%8C%E5%BC%82%E5%B8%B8-PYTHON/</url>
    <content><![CDATA[<p>Python 错误和异常<br>Python内置了一套异常处理机制，来帮助我们进行错误处理。<br>代码运行前的语法或逻辑错误<br>语法错误在执行前修改，逻辑错误无法修改<br>异常分为两个步骤：<br>异常产生，检查到错误且解释器认为是异常，抛出异常<br>异常处理，截获异常，忽略或终止程序处理异常</p>
<a id="more"></a>

<p>Python有两种错误很容易辨认：语法错误和异常。</p>
<h1 id="语法错误"><a href="#语法错误" class="headerlink" title="语法错误"></a>语法错误</h1><p>Python 的语法错误或者称之为解析错，是初学者经常碰到的，如下实例</p>
<blockquote>
<blockquote>
<blockquote>
<p>while True print(‘Hello world’)<br>  File “<stdin>“, line 1, in ?<br>    while True print(‘Hello world’)<br>                   ^<br>SyntaxError: invalid syntax<br>这个例子中，函数 print() 被检查到有错误，是它前面缺少了一个冒号（:）。<br>语法分析器指出了出错的一行，并且在最先找到的错误的位置标记了一个小小的箭头。</stdin></p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><p>即便Python程序的语法是正确的，在运行它的时候，也有可能发生错误。运行期检测到的错误被称为异常。<br>大多数的异常都不会被程序处理，都以错误信息的形式展现在这里:</p>
<blockquote>
<blockquote>
<blockquote>
<p>10 * (1/0)<br>Traceback (most recent call last):<br>  File “<stdin>“, line 1, in ?<br>ZeroDivisionError: division by zero<br>4 + spam*3<br>Traceback (most recent call last):<br>  File “<stdin>“, line 1, in ?<br>NameError: name ‘spam’ is not defined<br>‘2’ + 2<br>Traceback (most recent call last):<br>  File “<stdin>“, line 1, in ?<br>TypeError: Can’t convert ‘int’ object to str implicitly<br>异常以不同的类型出现，这些类型都作为信息的一部分打印出来: 例子中的类型有 ZeroDivisionError，NameError 和 TypeError。<br>错误信息的前面部分显示了异常发生的上下文，并以调用栈的形式显示具体信息。</stdin></stdin></stdin></p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p>以下例子中，让用户输入一个合法的整数，但是允许用户中断这个程序（使用 Control-C 或者操作系统提供的方法）。用户中断的信息会引发一个 KeyboardInterrupt 异常。</p>
<blockquote>
<blockquote>
<blockquote>
<p>while True:<br>        try:<br>            x = int(input(“Please enter a number: “))<br>            break<br>        except ValueError:<br>            print(“Oops!  That was no valid number.  Try again   “)<br>try语句按照如下方式工作；</p>
</blockquote>
</blockquote>
</blockquote>
<p>首先，执行try子句（在关键字try和关键字except之间的语句）<br>如果没有异常发生，忽略except子句，try子句执行后结束。<br>如果在执行try子句的过程中发生了异常，那么try子句余下的部分将被忽略。如果异常的类型和 except 之后的名称相符，那么对应的except子句将被执行。最后执行 try 语句之后的代码。<br>如果一个异常没有与任何的except匹配，那么这个异常将会传递给上层的try中。<br>一个 try 语句可能包含多个except子句，分别来处理不同的特定的异常。最多只有一个分支会被执行。<br>处理程序将只针对对应的try子句中的异常进行处理，而不是其他的 try 的处理程序中的异常。<br>一个except子句可以同时处理多个异常，这些异常将被放在一个括号里成为一个元组，例如:</p>
<p>except (RuntimeError, TypeError, NameError):<br>        pass<br>最后一个except子句可以忽略异常的名称，它将被当作通配符使用。你可以使用这种方法打印一个错误信息，然后再次把异常抛出。</p>
<p>import sys</p>
<p>try:<br>    f = open(‘myfile.txt’)<br>    s = f.readline()<br>    i = int(s.strip())<br>except OSError as err:<br>    print(“OS error: {0}”.format(err))<br>except ValueError:<br>    print(“Could not convert data to an integer.”)<br>except:<br>    print(“Unexpected error:”, sys.exc_info()[0])<br>    raise<br>try except 语句还有一个可选的else子句，如果使用这个子句，那么必须放在所有的except子句之后。这个子句将在try子句没有发生任何异常的时候执行。例如:</p>
<p>for arg in sys.argv[1:]:<br>    try:<br>        f = open(arg, ‘r’)<br>    except IOError:<br>        print(‘cannot open’, arg)<br>    else:<br>        print(arg, ‘has’, len(f.readlines()), ‘lines’)<br>        f.close()<br>使用 else 子句比把所有的语句都放在 try 子句里面要好，这样可以避免一些意想不到的、而except又没有捕获的异常。</p>
<p>异常处理并不仅仅处理那些直接发生在try子句中的异常，而且还能处理子句中调用的函数（甚至间接调用的函数）里抛出的异常。例如:</p>
<blockquote>
<blockquote>
<blockquote>
<p>def this_fails():<br>        x = 1/0</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>try:<br>        this_fails()<br>    except ZeroDivisionError as err:<br>        print(‘Handling run-time error:’, err)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Handling run-time error: int division or modulo by zero</p>
<h1 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h1><p>Python 使用 raise 语句抛出一个指定的异常。例如:</p>
<blockquote>
<blockquote>
<blockquote>
<p>raise NameError(‘HiThere’)<br>Traceback (most recent call last):<br>  File “<stdin>“, line 1, in ?<br>NameError: HiThere<br>raise 唯一的一个参数指定了要被抛出的异常。它必须是一个异常的实例或者是异常的类（也就是 Exception 的子类）。</stdin></p>
</blockquote>
</blockquote>
</blockquote>
<p>如果你只想知道这是否抛出了一个异常，并不想去处理它，那么一个简单的 raise 语句就可以再次把它抛出。</p>
<blockquote>
<blockquote>
<blockquote>
<p>try:<br>        raise NameError(‘HiThere’)<br>    except NameError:<br>        print(‘An exception flew by!’)<br>        raise</p>
</blockquote>
</blockquote>
</blockquote>
<p>An exception flew by!<br>Traceback (most recent call last):<br>  File “<stdin>“, line 2, in ?<br>NameError: HiThere</stdin></p>
<h1 id="用户自定义异常"><a href="#用户自定义异常" class="headerlink" title="用户自定义异常"></a>用户自定义异常</h1><p>你可以通过创建一个新的异常类来拥有自己的异常。异常类继承自 Exception 类，可以直接继承，或者间接继承，例如:</p>
<blockquote>
<blockquote>
<blockquote>
<p>class MyError(Exception):<br>        def <strong>init</strong>(self, value):<br>            self.value = value<br>        def <strong>str</strong>(self):<br>            return repr(self.value)</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>try:<br>        raise MyError(2*2)<br>    except MyError as e:<br>        print(‘My exception occurred, value:’, e.value)</p>
</blockquote>
</blockquote>
</blockquote>
<p>My exception occurred, value: 4</p>
<blockquote>
<blockquote>
<blockquote>
<p>raise MyError(‘oops!’)<br>Traceback (most recent call last):<br>  File “<stdin>“, line 1, in ?<br><strong>main</strong>.MyError: ‘oops!’<br>在这个例子中，类 Exception 默认的 <strong>init</strong>() 被覆盖。</stdin></p>
</blockquote>
</blockquote>
</blockquote>
<p>当创建一个模块有可能抛出多种不同的异常时，一种通常的做法是为这个包建立一个基础异常类，然后基于这个基础类为不同的错误情况创建不同的子类:</p>
<p>class Error(Exception):<br>    “””Base class for exceptions in this module.”””<br>    pass</p>
<p>class InputError(Error):<br>    “””Exception raised for errors in the input.</p>
<pre><code>Attributes:
    expression -- input expression in which the error occurred
    message -- explanation of the error
&quot;&quot;&quot;

def __init__(self, expression, message):
    self.expression = expression
    self.message = message</code></pre><p>class TransitionError(Error):<br>    “””Raised when an operation attempts a state transition that’s not<br>    allowed.</p>
<pre><code>Attributes:
    previous -- state at beginning of transition
    next -- attempted new state
    message -- explanation of why the specific transition is not allowed
&quot;&quot;&quot;

def __init__(self, previous, next, message):
    self.previous = previous
    self.next = next
    self.message = message</code></pre><p>大多数的异常的名字都以”Error”结尾，就跟标准的异常命名一样。</p>
<h1 id="定义清理行为"><a href="#定义清理行为" class="headerlink" title="定义清理行为"></a>定义清理行为</h1><p>try 语句还有另外一个可选的子句，它定义了无论在任何情况下都会执行的清理行为。 例如:</p>
<blockquote>
<blockquote>
<blockquote>
<p>try:<br>…     raise KeyboardInterrupt<br>… finally:<br>…     print(‘Goodbye, world!’)<br>…<br>Goodbye, world!<br>Traceback (most recent call last):<br>  File “<stdin>“, line 2, in <module><br>KeyboardInterrupt<br>以上例子不管 try 子句里面有没有发生异常，finally 子句都会执行。</module></stdin></p>
</blockquote>
</blockquote>
</blockquote>
<p>如果一个异常在 try 子句里（或者在 except 和 else 子句里）被抛出，而又没有任何的 except 把它截住，那么这个异常会在 finally 子句执行后被抛出。</p>
<p>下面是一个更加复杂的例子（在同一个 try 语句里包含 except 和 finally 子句）:</p>
<blockquote>
<blockquote>
<blockquote>
<p>def divide(x, y):<br>        try:<br>            result = x / y<br>        except ZeroDivisionError:<br>            print(“division by zero!”)<br>        else:<br>            print(“result is”, result)<br>        finally:<br>            print(“executing finally clause”)</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>divide(2, 1)<br>result is 2.0<br>executing finally clause<br>divide(2, 0)<br>division by zero!<br>executing finally clause<br>divide(“2”, “1”)<br>executing finally clause<br>Traceback (most recent call last):<br>  File “<stdin>“, line 1, in ?<br>  File “<stdin>“, line 3, in divide<br>TypeError: unsupported operand type(s) for /: ‘str’ and ‘str’</stdin></stdin></p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="预定义的清理行为"><a href="#预定义的清理行为" class="headerlink" title="预定义的清理行为"></a>预定义的清理行为</h1><p>一些对象定义了标准的清理行为，无论系统是否成功的使用了它，一旦不需要它了，那么这个标准的清理行为就会执行。<br>下面这个例子展示了尝试打开一个文件，然后把内容打印到屏幕上:</p>
<p>for line in open(“myfile.txt”):<br>    print(line, end=””)<br>以上这段代码的问题是，当执行完毕后，文件会保持打开状态，并没有被关闭。</p>
<p>关键词 with 语句就可以保证诸如文件之类的对象在使用完之后一定会正确的执行他的清理方法:</p>
<p>with open(“myfile.txt”) as f:<br>    for line in f:<br>        print(line, end=””)<br>以上这段代码执行完毕后，就算在处理过程中出问题了，文件 f 总是会关闭。</p>
]]></content>
      <categories>
        <category>基础进阶</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>安装常用工具包-LINUX</title>
    <url>/2020/03/19/%E5%AE%89%E8%A3%85%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E5%8C%85-LINUX/</url>
    <content><![CDATA[<p>全部操作都在root用户下执行</p>
<a id="more"></a>
<h1 id="安装编译相关工具"><a href="#安装编译相关工具" class="headerlink" title="安装编译相关工具"></a>安装编译相关工具</h1><p>yum -y groupinstall “Development tools”<br>yum -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel<br>yum install libffi-devel -y<br>2.下载安装包解压<br>wget <a href="https://www.python.org/ftp/python/3.7.0/Python-3.7.0.tar.xz" target="_blank" rel="noopener">https://www.python.org/ftp/python/3.7.0/Python-3.7.0.tar.xz</a><br>tar -xvJf  Python-3.7.0.tar.xz<br>3.编译安装<br>mkdir /usr/local/python3 #创建编译安装目录<br>cd Python-3.7.0<br>./configure –prefix=/usr/local/python3<br>make &amp;&amp; make install<br>4.创建软连接<br>ln -s /usr/local/python3/bin/python3 /usr/local/bin/python3<br>ln -s /usr/local/python3/bin/pip3 /usr/local/bin/pip3<br>5.验证是否成功<br>python3 -V<br>pip3 -V</p>
<h1 id="添加Nginx的源"><a href="#添加Nginx的源" class="headerlink" title="添加Nginx的源"></a>添加Nginx的源</h1><p>rpm -Uvh <a href="http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm" target="_blank" rel="noopener">http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm</a></p>
<h1 id="安装Nginx"><a href="#安装Nginx" class="headerlink" title="安装Nginx"></a>安装Nginx</h1><p>yum install -y nginx<br>安装成功后，配置文件目录为/etc/nginx</p>
<h1 id="启动Nginx"><a href="#启动Nginx" class="headerlink" title="启动Nginx"></a>启动Nginx</h1><p>systemctl start nginx.service #启动Nginx<br>systemctl enable nginx.service #设置开机自启</p>
<h1 id="yum安装redis"><a href="#yum安装redis" class="headerlink" title="yum安装redis"></a>yum安装redis</h1><p>yum install -y epel-release<br>yum install -y redis</p>
<h1 id="启动redis"><a href="#启动redis" class="headerlink" title="启动redis"></a>启动redis</h1><p>service redis start #启动redis<br>service redis status #查看redis状态</p>
<hr>
<p>ps -ef | grep redis #查看redis进程<br>service redis stop #停止redis</p>
<h1 id="设置开机自启"><a href="#设置开机自启" class="headerlink" title="设置开机自启"></a>设置开机自启</h1><p>chkconfig redis on</p>
<h1 id="修改redis配置"><a href="#修改redis配置" class="headerlink" title="修改redis配置"></a>修改redis配置</h1><p>vim /etc/redis.conf<br>修改如下内容:</p>
<p>port 6379 #启动端口<br>requirepass 111111 #访问密码<br>重启redis</p>
<p>service redis restart<br>登录redis<br>注: 127.0.0.1:6379&gt;为redis数据库前缀</p>
<p>redis-cli #登录redis<br>127.0.0.1:6379&gt; auth 111111 #认证登录<br>127.0.0.1:6379&gt; keys * #查看当前的key</p>
<h1 id="下载安装mysql-yum-源"><a href="#下载安装mysql-yum-源" class="headerlink" title="下载安装mysql yum 源"></a>下载安装mysql yum 源</h1><p>wget -i -c <a href="http://dev.mysql.com/get/mysql57-community-release-el7-10.noarch.rpm" target="_blank" rel="noopener">http://dev.mysql.com/get/mysql57-community-release-el7-10.noarch.rpm</a><br>yum install -y mysql57-community-release-el7-10.noarch.rpm<br>安装mysql并启动<br>yum install -y mysql-community-server #安装mysql<br>systemctl start  mysqld.service #启动<br>systemctl status mysqld.service #查看运行状态<br>登录mysql<br>grep “password” /var/log/mysqld.log #查看mysql生成的密码<br>mysql -uroot -p #以root用户登录mysql<br>修改root密码<br>注: mysql&gt; 为提示符；新密码需符合：包含字母大小写、特殊符和数字，且位数大于4</p>
<p>mysql&gt; ALTER USER ‘root’@’localhost’ IDENTIFIED BY ‘new password’;<br> 授权root用户远程访问<br>mysql&gt; use mysql;<br>mysql&gt; grant all privileges  on <em>.</em> to root@’%’ identified by “password”;<br>mysql&gt; flush privileges;</p>
<h1 id="下载sqlite安装包"><a href="#下载sqlite安装包" class="headerlink" title="下载sqlite安装包"></a>下载sqlite安装包</h1><p>cd /opt<br>wget <a href="http://www.sqlite.org/2015/sqlite-autoconf-3081101.tar.gz" target="_blank" rel="noopener">http://www.sqlite.org/2015/sqlite-autoconf-3081101.tar.gz</a> #下载安装包<br>tar zxvf sqlite-autoconf-3081101.tar.gz  #进行解压<br>3.编译安装<br>cd sqlite-autoconf-3081101/<br>./configure<br>make &amp;&amp; make install<br>yum install sqlite-devel<br>4.链接sqlite3<br>cd #回到用户目录<br>sqlite3 #链接sqlite3</p>
<p>5.退出sqlite3<br>sqlite3链接成功后，执行如下：</p>
<p>sqlite&gt; .quit #退出sqlite3</p>
]]></content>
      <categories>
        <category>基础-Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>定时任务-LINUX</title>
    <url>/2020/03/19/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1-LINUX/</url>
    <content><![CDATA[<h4 id="定时任务分为两种模式"><a href="#定时任务分为两种模式" class="headerlink" title="定时任务分为两种模式"></a>定时任务分为两种模式</h4><p> 1.系统级别的定时任务：临时文件清理、系统信息采集、日志文件切割<br> 2.用户级别的定时任务：定时向互联网同步时间、定时备份系统配置文件、定时备份数据库的数据 </p>
<a id="more"></a>
<h4 id="定时任务-标准规范"><a href="#定时任务-标准规范" class="headerlink" title="定时任务 标准规范"></a>定时任务 标准规范</h4><pre><code class="shell">[root@oldboy ~]# vim /etc/crontab
SHELL=/bin/bash        执行命令的解释器
PATH=/sbin:/bin:/usr/sbin:/usr/bin       环境变量
MAILTO=root           邮件发给谁

# For details see man 4 crontabs

# Example of job definition:
# .---------------- minute (0 - 59)     分钟
# |  .------------- hour (0 - 23)     小时
# |  |  .---------- day of month (1 - 31)     日期
# |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...        月份
# |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat  星期
# |  |  |  |  |
# *  *  *  *  * user-name  command to be executed

 *  表示任意的(分、时、日、月、周)时间都执行
 -  表示一个时间范围段, 如5-7点
 ,  表示分隔时段, 如6,0,4表示周六、日、四
 /1 表示每隔n单位时间, 如*/10 每10分钟</code></pre>
<h4 id="常用的一些定时任务段"><a href="#常用的一些定时任务段" class="headerlink" title="常用的一些定时任务段"></a>常用的一些定时任务段</h4><pre><code class="shell">00 02 * * * ls      #每天的凌晨2点整执行
00 02 1 * * ls      #每月的1日的凌晨2点整执行
00 02 14 2 * ls     #每年的2月14日凌晨2点执行
00 02 * * 7 ls      #每周天的凌晨2点整执行
00 02 * 6 5 ls      #每年的6月周五凌晨2点执行
00 02 14 * 7 ls     #每月14日或每周日的凌晨2点都执行
00 02 14 2 7 ls     #每年的2月14日或每年2月的周天的凌晨2点执行   
*/10  02 * * * ls   #每天凌晨2点，每隔10分钟执行一次
* * * * *  ls       #每分钟都执行
00 00 14 2 *  ls    #每年2月14日的凌晨执行命令 
*/5 * * * *  ls     #每隔5分钟执行一次
00 02 * 1,5,8 * ls  #每年的1月5月8月凌晨2点执行
00 02 1-8 * *  ls    #每月1号到8号凌晨2点执行
0 21 * * * ls       #每天晚上21:00执行
45 4 1,10,22 * * ls #每月1、10、22日的4:45执行
45 4 1-10 * * l     #每月1到10日的4:45执行
3,15 8-11 */2 * * ls #每隔两天的上午8点到11点的第3和第15分钟执行
0 23-7/1 * * * ls   #晚上11点到早上7点之间，每隔一小时执行
15 21 * * 1-5 ls    #周一到周五每天晚上21:15执行</code></pre>
]]></content>
      <categories>
        <category>基础进阶-Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>条件循环和判断-PYTHON</title>
    <url>/2020/03/19/%E6%9D%A1%E4%BB%B6%E5%BE%AA%E7%8E%AF%E5%92%8C%E5%88%A4%E6%96%AD-PYTHON/</url>
    <content><![CDATA[<p>条件判断的重要值是True和False，注意首字母大写，示例如下：</p>
<a id="more"></a>
<pre><code>if True:
    print(&quot;真&quot;)
else:
    print(&quot;假&quot;)
# 输出：真</code></pre><h1 id="非真判断"><a href="#非真判断" class="headerlink" title="非真判断"></a>非真判断</h1><p>非真判断使用not关键字，示例如下：</p>
<pre><code>if not True:
    print(&quot;True&quot;)
else:
    print(&quot;False&quot;)
# 输出：False</code></pre><h1 id="多情况判断"><a href="#多情况判断" class="headerlink" title="多情况判断"></a>多情况判断</h1><p>多情况判断使用if/elif/else，示例如下：</p>
<pre><code>age = 18
if age &lt; 16:
    print(&quot;青少年&quot;)
elif age &lt; 18:
    print(&quot;青年&quot;)
elif age &lt; 60:
    print(&quot;成人&quot;)
else:
    print(&quot;老年&quot;)
# 输出：成人</code></pre><p>python用空格缩进代表代码块，所以要主要代码缩进.</p>
<h1 id="满足多条件"><a href="#满足多条件" class="headerlink" title="满足多条件"></a>满足多条件</h1><p>使用and关键字，示例如下：</p>
<pre><code>age = 18
name = &quot;laowang&quot;
if age == 18 and name == &quot;laowang&quot;:
    print(&quot;良好少年&quot;)
else:
    print(&quot;不良少年&quot;)
# 输出：良好少年</code></pre><h1 id="至少满足一种条件"><a href="#至少满足一种条件" class="headerlink" title="至少满足一种条件"></a>至少满足一种条件</h1><p>使用or关键字，示例如下：</p>
<pre><code>age = 18
name = &quot;laowang&quot;
if age == 18 or name == &quot;xiaoli&quot;:
    print(&quot;良好少年&quot;)
else:
    print(&quot;不良少年&quot;)
# 输出：良好少年</code></pre><p><strong>False值</strong><br>python中0、空字符串、空列表、空元祖值、空字典都为false.</p>
<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p><strong>for循环</strong><br>基础示例如下：</p>
<pre><code>list = [&quot;focus&quot;, &quot;mouse&quot;, &quot;click&quot;]
for item in list:
    print(item)
# 输出：focus
# 输出：mouse
# 输出：click</code></pre><h1 id="break跳出循环"><a href="#break跳出循环" class="headerlink" title="break跳出循环"></a>break跳出循环</h1><pre><code>list = [&quot;focus&quot;, &quot;mouse&quot;, &quot;click&quot;]
for item in list:
    if item == &quot;mouse&quot;:
        break
    print(item)
# 输出：focus</code></pre><h1 id="continue跳过该次循环"><a href="#continue跳过该次循环" class="headerlink" title="continue跳过该次循环"></a>continue跳过该次循环</h1><pre><code>list = [&quot;focus&quot;, &quot;mouse&quot;, &quot;click&quot;]
for item in list:
    if item == &quot;mouse&quot;:
        continue
    print(item)
# 输出：focus
# 输出：click</code></pre><h1 id="使用enumerate获取下标"><a href="#使用enumerate获取下标" class="headerlink" title="使用enumerate获取下标"></a>使用enumerate获取下标</h1><pre><code>list = [&quot;focus&quot;, &quot;mouse&quot;, &quot;click&quot;]
for index, item in enumerate(list):
    print(&quot;index:{} item:{}&quot;.format(index, item))
# 输出如下：
# index:0 item:focus
# index:1 item:mouse
# index:2 item:click</code></pre><h1 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h1><p>基础示例如下：</p>
<pre><code>num = 1
while num &lt; 3:
    print(num)
    num = num+1
# 输出：1
# 输出：2</code></pre><p>在while中break和continue同样有效，和上文for循环作用相同，请参考上文。</p>
]]></content>
      <categories>
        <category>基础常识</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>时间模块-PYTHON</title>
    <url>/2020/03/19/%E6%97%B6%E9%97%B4%E6%A8%A1%E5%9D%97-PYTHON/</url>
    <content><![CDATA[<p>python中使用时间需要导入time模块，使用time.time()方法获取当前时间戳，示例如下：</p>
<a id="more"></a>
<pre><code># 导入time模块
import time

print(time.time())
# 输出：1523584077.842348
</code></pre><h2 id="格式化时间"><a href="#格式化时间" class="headerlink" title="格式化时间"></a>格式化时间</h2><p>格式化时间，使用time中的strftime()，示例如下：</p>
<pre><code># 导入time模块
import time

print(time.time())
# 输出：1523584077.842348

print(time.localtime(time.time()))
# 输出：time.struct_time(tm_year=2018, tm_mon=4, tm_mday=13, tm_hour=9, tm_min=50, tm_sec=12, tm_wday=4, tm_yday=103, tm_isdst=0)

# 时间格式化
print(time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, time.localtime(time.time())))
# 输出：2018-04-13 09:52:10</code></pre><p><strong>程序计时器</strong></p>
<p>使用场景：有时候我们需要计算程序的运行时长，使用以下代码：</p>
<pre><code>import datetime
import time

#开始计时
startTime = datetime.datetime.now()

time.sleep(1)

#结束计时
endTime = datetime.datetime.now()
print(endTime - startTime)
#输出：0:00:01.000791</code></pre><h2 id="格式化符号说明"><a href="#格式化符号说明" class="headerlink" title="格式化符号说明"></a>格式化符号说明</h2><p>%y 两位数的年份表示（00-99）</p>
<p>%Y 四位数的年份表示（000-9999）</p>
<p>%m 月份（01-12）</p>
<p>%d 月内中的一天（0-31）</p>
<p>%H 24小时制小时数（0-23）</p>
<p>%I 12小时制小时数（01-12）</p>
<p>%M 分钟数（00=59）</p>
<p>%S 秒（00-59）</p>
<p>%a 本地简化星期名称</p>
<p>%A 本地完整星期名称</p>
<p>%b 本地简化的月份名称</p>
<p>%B 本地完整的月份名称</p>
<p>%c 本地相应的日期表示和时间表示</p>
<p>%j 年内的一天（001-366）</p>
<p>%p 本地A.M.或P.M.的等价符</p>
<p>%U 一年中的星期数（00-53）星期天为星期的开始</p>
<p>%w 星期（0-6），星期天为星期的开始</p>
<p>%W 一年中的星期数（00-53）星期一为星期的开始</p>
<p>%x 本地相应的日期表示</p>
<p>%X 本地相应的时间表示</p>
<p>%Z 当前时区的名称</p>
<p>%% %号本身</p>
]]></content>
      <categories>
        <category>基础常识</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>文件操作-PYTHON</title>
    <url>/2020/03/19/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C-PYTHON/</url>
    <content><![CDATA[<h2 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h2><p>读取文件使用python内置方法open()打开文件，使用.read()读取全部内容，示例如下：</p>
<a id="more"></a>
<pre><code>path = &quot;c:\py.txt&quot;
fi = open(path, &quot;r&quot;)
print(fi.read())
fi.close()</code></pre><p><strong>with语法</strong></p>
<p>with是python2.5引入的自动释放资源的语法模式，确保使用过程中不管是否发生了异常，都会释放资源.<br>使用with读取文件，是不需要自己手动close的，示例如下：</p>
<pre><code>with open(path) as fi:
    print(fi.read())</code></pre><p><strong>逐行读取文件</strong><br>.read()是读取文件的全部内容，使用.readlines()，示例如下：</p>
<pre><code>with open(path, &quot;r&quot;) as fi:
    lines = fi.readlines()
print(len(lines))</code></pre><p><strong>open方法的模式</strong></p>
<p>上面的示例可以看出来，open(目录,操作模式)的时候必须指定操作模式，open的操作模式：</p>
<blockquote>
<p>读取模式：’r’(默认模式) | 写入模式：’w’ | 附加模式：’a’.</p>
</blockquote>
<p>python模式是读取，所以”r”可以省略，示例如下：</p>
<pre><code>path = &quot;c:\py.txt&quot;
fi = open(path)
print(fi.read())
fi.close()</code></pre><h2 id="文件写入"><a href="#文件写入" class="headerlink" title="文件写入"></a>文件写入</h2><p>文件写入分为两种方式，一种是覆盖(w)，另一种是追加(a)。</p>
<p>文件覆盖的写入，代码如下：</p>
<pre><code>with open(path, &quot;w&quot;) as fi:
    fi.write(&quot;第一行\n第二行\n第三行&quot;)</code></pre><p>文件的追加，代码如下：</p>
<pre><code>with open(path, &quot;a&quot;) as fi:
    fi.write(&quot;\n第1行\n第2行\n第3行&quot;)</code></pre><blockquote>
<p>注意：文件写入，如果文件不存在会重建，不会报错。</p>
</blockquote>
<h2 id="更多文件操作"><a href="#更多文件操作" class="headerlink" title="更多文件操作"></a>更多文件操作</h2><p>os.getcwd()：获取当前运行目录</p>
<p>os.listdir(path)：获取指定目录下的列表</p>
<p>os.path.exists(path)：检查是否存在文件或文件夹</p>
<p>os.mkdir(path)：创建文件夹，已经存在文件会报错</p>
<p>os.remove(path)：删除文件夹，只能删除文件夹</p>
<p>os.rename(old, new)：文件重命名</p>
<p>示例如下：</p>
<pre><code>import os

# 获取当前程序运行目录
print(os.getcwd())

# 获取指定目录下的列表
print(os.listdir(&quot;E:\\server&quot;))

# 检查是否存在文件或文件夹
print(os.path.exists(&quot;E:\\test\\a.txt&quot;))

# 创建文件夹，已经存在文件会报错
os.mkdir(&quot;E:\\test1&quot;)

# 删除文件夹，只能删除文件夹
os.remove(&quot;E:\\test1&quot;)

# 文件重命名
os.rename(&quot;E:\\test\\a.txt&quot;, &quot;E:\\test\\b.txt&quot;)
</code></pre>]]></content>
      <categories>
        <category>基础常识</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>内置模块---PYTHON</title>
    <url>/2020/03/18/%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97-PYTHON/</url>
    <content><![CDATA[<p>常用内置模块列表：</p>
<ul>
<li>os</li>
<li>sys</li>
<li>json</li>
</ul>
<a id="more"></a>

<h1 id="os模块"><a href="#os模块" class="headerlink" title="os模块"></a>os模块</h1><p>os.getcwd() #获取当前程序目录</p>
<p>os.listdir(‘dirname’) #列出指定目录下的所有文件和子目录，包括隐藏文件，并以列表方式打印</p>
<p>os.remove() #删除一个文件</p>
<p>os.rename(“oldname”,”newname”) #重命名文件/目录</p>
<p>os.path.isfile(path) #如果path是一个存在的文件，返回True，否则返回False</p>
<p>os.path.exists(path) #如果path存在，返回True；如果path不存在，返回False</p>
<p>os.path.getatime(path) #返回path所指向的文件或者目录的最后存取时间</p>
<p>os.path.getmtime(path) #返回path所指向的文件或者目录的最后修改时间</p>
<h1 id="sys模块"><a href="#sys模块" class="headerlink" title="sys模块"></a>sys模块</h1><p>sys.exit(n) #退出程序，正常退出时exit(0)</p>
<p>sys.version  #获取Python解释程序的版本信息</p>
<p>sys.maxint #最大的Int值</p>
<p>sys.platform #返回操作系统平台名称</p>
<h1 id="json模块"><a href="#json模块" class="headerlink" title="json模块"></a>json模块</h1><p>json模块用于字符串 和 python数据类型间进行转换</p>
<p>json模块提供了四个功能：dumps、dump、loads、load</p>
<p>dumps、dump #把对象转换成str</p>
<p>loads、load #把str转换成json</p>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>垃圾回收gc</title>
    <url>/2020/03/18/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6gc/</url>
    <content><![CDATA[<hr>
<p>python的垃圾收回机制不想c和c++是开发者自己管理维护内存的，python的垃圾回收是系统自己处理的，所以作为普通的开发者，我们不需要关注垃圾回收部分的内容，如果想要深层次理解python请继续看下文。</p>
<a id="more"></a>

<p><strong>python垃圾回收机制</strong><br>Python的GC模块主要运用了引用计数来跟踪和回收垃圾。在引用计数的基础上，还可以通过“标记－清除”解决容器对象可能产生的循环引用的问题。通过分代回收以空间换取时间进一步提高垃圾回收的效率。</p>
<h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><p><strong>原理：</strong>当一个对象的引用被创建或者复制时，对象的引用计数加1；当一个对象的引用被销毁时，对象的引用计数减1，当对象的引用计数减少为0时，就意味着对象已经再没有被使用了，可以将其内存释放掉。</p>
<p><strong>优点：</strong>引用计数有一个很大的优点，即实时性，任何内存，一旦没有指向它的引用，就会被立即回收，而其他的垃圾收集技术必须在某种特殊条件下才能进行无效内存的回收。</p>
<p><strong>缺点：</strong>但是它也有弱点，引用计数机制所带来的维护引用计数的额外操作与Python运行中所进行的内存分配和释放，引用赋值的次数是成正比的，这显然比其它那些垃圾收集技术所带来的额外操作只是与待回收的内存数量有关的效率要低。同时，引用技术还存在另外一个很大的问题－循环引用，因为对象之间相互引用，每个对象的引用都不会为0，所以这些对象所占用的内存始终都不会被释放掉。</p>
<h2 id="标记－清除"><a href="#标记－清除" class="headerlink" title="标记－清除"></a>标记－清除</h2><p>标记－清除只关注那些可能会产生循环引用的对象，显然，像是PyIntObject、PyStringObject这些不可变对象是不可能产生循环引用的，因为它们内部不可能持有其它对象的引用。Python中的循环引用总是发生在container对象之间，也就是能够在内部持有其它对象的对象，比如list、dict、class等等。这也使得该方法带来的开销只依赖于container对象的的数量。</p>
<p><strong>原理：</strong></p>
<ol>
<li>寻找跟对象（root object）的集合作为垃圾检测动作的起点，跟对象也就是一些全局引用和函数栈中的引用，这些引用所指向的对象是不可被删除的；</li>
<li>从root object集合出发，沿着root object集合中的每一个引用，如果能够到达某个对象，则说明这个对象是可达的，那么就不会被删除，这个过程就是垃圾检测阶段；</li>
<li>当检测阶段结束以后，所有的对象就分成可达和不可达两部分，所有的可达对象都进行保留，其它的不可达对象所占用的内存将会被回收，这就是垃圾回收阶段。（底层采用的是链表将这些集合的对象连接在一起）；</li>
</ol>
<p><strong>缺点：</strong>标记和清除的过程效率不高。</p>
<h2 id="分代回收"><a href="#分代回收" class="headerlink" title="分代回收"></a>分代回收</h2><p><strong>原理：</strong>将系统中的所有内存块根据其存活时间划分为不同的集合，每一个集合就成为一个“代”，Python默认定义了三代对象集合，垃圾收集的频率随着“代”的存活时间的增大而减小。也就是说，活得越长的对象，就越不可能是垃圾，就应该减少对它的垃圾收集频率。那么如何来衡量这个存活时间：通常是利用几次垃圾收集动作来衡量，如果一个对象经过的垃圾收集次数越多，可以得出：该对象存活时间就越长。</p>
]]></content>
      <categories>
        <category>基础常识</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP 模块</title>
    <url>/2020/03/18/HTTP-%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<p>python中的http/https请求使用urllib库，使用urllib的request模块的发送get和post请求。  </p>
<a id="more"></a>
<h2 id="get请求"><a href="#get请求" class="headerlink" title="get请求"></a>get请求</h2><p>请求网页地址并返回网页html内容，示例如下：</p>
<pre><code>from urllib import request


def getHtml(url):
    with request.urlopen(url) as r:
        data = r.read()
        return data.decode(&quot;utf-8&quot;)


print(getHtml(&quot;http://vipstone.cnblogs.com&quot;))</code></pre><p>对返回的数据进行编码处理data.decode(“utf-8”)即可。</p>
<h2 id="post请求"><a href="#post请求" class="headerlink" title="post请求"></a>post请求</h2><p>post请求并传递参数，对参数进行encode处理，示例如下：</p>
<pre><code>from urllib import request, parse


params = parse.urlencode([(&quot;name&quot;, &quot;老王&quot;), (&quot;pwd&quot;, &quot;123456&quot;)])
req = request.Request(&quot;http://127.0.0.1:8360/video/login&quot;)
req.add_header(&quot;User-Agent&quot;, &quot;Mozilla/6.0 (iPhone; CPU iPhone OS 8_0 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Version/8.0 Mobile/10A5376e Safari/8536.25&quot;)

with request.urlopen(req, data=params.encode(&quot;utf-8&quot;)) as r:
    data = r.read()
    print(data.decode(&quot;utf-8&quot;))</code></pre><p>如上所示，需要使用urllib的parse对参数进行编码处理，也可以给http头添加内容。</p>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>人工智能三学派</title>
    <url>/2020/03/17/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E4%B8%89%E5%AD%A6%E6%B4%BE/</url>
    <content><![CDATA[<p>人工智能：</p>
<p>让机器具备人的思维和意识。</p>
<p>人工智能三学派：</p>
<a id="more"></a>

<p>行为主义：基于控制论，构建感知-动作控制系统（控制论：平衡/行走/避障等自适应控制系统）</p>
<p>符号主义：基于算术逻辑表达式，求解问题先把问题描述为表达式，在求解表达式。（可用公式描述，实现理性思维）</p>
<p>连接主义：仿生学，模仿神经元连接关系（放脑神经元连接，实现感性思维，例如神经网络）</p>
<p>用计算机仿出神经网络的连接关系让计算机具备感性思维。</p>
<ol>
<li>准备数据（采集大量“特征/标签”数据）</li>
<li>搭建网络（搭建神经网络结构）</li>
<li>优化参数（训练网络获取最佳参数【反向传播：优化连接的权重知道模型的识别准确率达到要求，得到最优的连线权重，保存】）</li>
<li>应用网络（将网络保存为模型，输入新数据，输出分类或预测结果【前向传播：输出概率值 概率值最大的就是分类和预测的结果】）</li>
</ol>
]]></content>
      <tags>
        <tag>A.I.</tag>
      </tags>
  </entry>
</search>
